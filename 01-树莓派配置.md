# 备注信息

- 1.树莓派带桌面版本整体配置完成，带设置OLED，配置了摄像头，按键开关机功能，安装了OpenCV（忘记成功了没）

- 2.现在对其进行一个镜像的备份；

- sandisk 32G安装full版本，用户名pi，密码jy890428，root：jy911229

- 

# 

# 12个Linux进程管理命令介绍

**为了管理这些进程，用户应该能够：**

●查看所有运行中的进程

●查看进程消耗资源

●定位个别进程并且对其执行指定操作

●改变进程的优先级

●杀死指定进程

●限制进程可用的系统资源等

[Linux](https://www.linuxprobe.com/ "linux")提供了许多[命令](https://www.linuxcool.com/ "命令")来让用户来高效掌控上述的操作。接下来，一个一个的来讲解下。

**1.ps**

'ps'是Linux 中最基础的浏览系统中的进程的[命令](https://www.linuxcool.com/ "命令")。能列出系统中运行的进程，包括进程号、命令、CPU使用量、内存使用量等。下述选项可以得到更多有用的消息。

ps -a - 列出所有运行中/激活进程

ps -ef |grep - 列出需要进程

ps -aux - 显示进程信息，包括无终端的（x）和针对用户（u）的进程：如USER, PID, %CPU, %MEM等

**2.pstree**

linux中，每一个进程都是由其父进程创建的。此命令以可视化方式显示进程，通过显示进程的树状图来展示进程间关系。如果指定了pid了，那么树的根是该pid，不然将会是init（pid： 1）。

**3.top**

‘top’是一个更加有用的命令，可以监视系统中不同的进程所使用的资源。它提供实时的系统状态信息。显示进程的数据包括PID、进程属主、优先级、%CPU、%memory等。可以使用这些显示指示出资源使用量。

**4.htop**

htop与top很类似，但是htop是交互式的文本模式的进程查看器。它通过文字图形化地显示每一个进程的CPU和内存使用量、swap使用量。使用上下光标键选择进程，F7和F8改变优先级，F9杀死进程。Htop不是系统默认安装的，所以需要额外安装。

**5.nice**

通过nice命令的帮助，用户可以设置和改变进程的优先级。提高一个进程的优先级，内核会分配更多CPU时间片给这个进程。默认情况下，进程以0的优先级启动。进程优先级可以通过top命令显示的NI（nice value）列查看。

进程优先级值的范围从-20到19。值越低，优先级越高。

nice <优先值> <进程名> - 通过给定的优先值启动一个程序

上述命令例子中，可以看到‘top’命令获得了-3的优先值。

**6.renice**

renice命令类似nice命令。使用这个命令可以改变正在运行的进程优先值。注意，用户只能改变属于他们自己的进程的优先值。

renice -n -p - 改变指定进程的优先值

初始优先值为0的3806号进程优先值已经变成了4。

renice -u -g - 通过指定用户和组来改变进程优先值

上述例子中，用户为‘mint’的所有进程优先值变为‘-3’。

**7.kill**

这个命令用于发送信号来结束进程。如果一个进程没有响应杀死命令，这也许就需要强制杀死，使用-9参数来执行。注意，使用强制杀死的时候一定要小心，因为进程没有时机清理现场，也许写入文件没有完成。如果我们不知道进程PID或者打算用名字杀死进程时候，killall就能派上用场。

kill <pid>

kill -9 <pid>

killall -9 - 杀死所有拥有同样名字的进程

如果你使用kill，你需要知道进程ID号。pkill是类似的命令，但使用模式匹配，如进程名，进程拥有者等。

pkill <进程名>

**8.ulimit**

该命令用于控制系统资源在[shell](https://www.linuxcool.com/ "shell")和进程上的分配量。对于系统管理员是最有用的，可以管理重度使用和存在性能问题的系统。限制资源大小可以确保重要进程持续运行，其他进程不会占用过多资源。

ulimit -a - 显示当前用户关联的资源限制

-f :最大文件尺寸大小

-v :最大虚拟内存大小（KB）

-n :增加最大文件描述符数量

-H :改变和报告硬限制

-S :改变和报告软限制

浏览ulimit man页面获取更多选项。

**9.w**

w 提供当前登录的用户及其正在执行的进程的信息。显示信息头包含信息，如当前时间、系统运行时长、登录用户总数、过去的1，5，15分钟内的负载均衡数。

基于这些用户信息，用户在终止不属于他们的进程时要小心。

who是类似命令，提供当前登录用户列表、系统启动时间、运行级别等。

whoami 命令输出当前用户ID

**10.pgrep**

pgrep的意思是"进程号全局正则匹配输出"。该命令扫描当前运行进程，然后按照命令匹配条件列出匹配结果到标准输出。对于通过名字检索进程号是很有用。

pgrep -u mint sh

这个命令将会显示用户为‘mint’和进程名为‘sh’的进程ID。

**11.fg , bg**

有时，命令需要很长的时间才能执行完成。对于这种情况，我们使用‘bg’命令可以将任务放在后台执行，而用‘fg’可以调到前台来使用。

我们可以通过‘&’在后台启动一个程序：

find . -name *iso > /tmp/res.txt &

一个正在运行的程序也可以通过“CTRL+Z”和“bg”命令组合放到后台运行。

find . -name *iso > /tmp/res.txt & - 启动一个程序

ctrl+z - 挂起当前执行程序

bg - 将程序放到后台运行

我们可以使用‘jobs’命令列出所有后台进程。

jobs

使用‘fg’命令可以将后台程序调到前台执行。

fg %进程id

**12.ipcs**

ipcs命令报告进程间通信设施状态。（共享内存，信号量和消息队列）

用-p参数联合-m、-s或-q使用，可以获得相关的进程间通信的进程ID。

ipcs -p -m

下面屏幕截图列出了最近访问了共享内存段的进程的创建者的ID和进程ID。

**总结**

总之 ，这些命令可以帮助管理员修复问题和改善性能。同样作为一名普通用户也需要解决进程出现的问题。所以，熟悉如此繁多的命令，从能有效管理进程是行之有效。

# # 生成树莓派的最小系统镜像

###### [Linux](https://www.ucloud.cn/yun/linux/)

**开发 / 测试环境**

树莓派：**Raspberry Pi 3b**

TF 存储卡：**SanDisk Ultra 16GB Class 10 A1**

操作系统：**2018-06-27-raspbian-stretch-lite**

程序：使用**apt-get**安装的最新版本（2018年7月15日）

**脚本**

脚本**raspberrypi-backup.sh**用于生成树莓派的最小系统镜像。

该脚本能够将位于 TF 存储卡上的数据备份到**通过USB连接的存储设备**上。镜像的大小取决于 TF 存储卡的已用空间。

**脚本接受1个必要参数：存放镜像的目录。**每次执行，脚本会在该目录中生成一个**img**文件，文件名为**backup_当前日期与时间.img**。

```bash
#!/bin/bash
set -e

# start

if [ -z $1 ]; then
  echo "Backup directory not set, required."
  exit 1
fi
BACK_UP_DIR=$1
echo

# install

echo "Installing package ..."
apt-get install dosfstools dump parted kpartx -y
echo "Finish."
echo

# create image

echo "Creating image ..."
ROOT=`df -P | grep /dev/root | awk '{print $3}'`
MMCBLK0P1=`df -P | grep /dev/mmcblk0p1 | awk '{print $2}'`
ALL=`echo $ROOT $MMCBLK0P1 |awk '{print int(($1+$2)*1.2)}'`
TIME=`date "+%Y%m%d%H%M%S"`
FILE=$BACK_UP_DIR/backup_$TIME.img
dd if=/dev/zero of=$FILE bs=1K count=$ALL
echo "Finish."
echo

# part

echo "Parting image ..."
P1_START=`fdisk -l /dev/mmcblk0 | grep /dev/mmcblk0p1 | awk '{print $2}'`
P1_END=`fdisk -l /dev/mmcblk0 | grep /dev/mmcblk0p1 | awk '{print $3}'`
P2_START=`fdisk -l /dev/mmcblk0 | grep /dev/mmcblk0p2 | awk '{print $2}'`
parted $FILE --script -- mklabel msdos
parted $FILE --script -- mkpart primary fat32 ${P1_START}s ${P1_END}s
parted $FILE --script -- mkpart primary ext4 ${P2_START}s -1
parted $FILE --script -- quit
echo "Finish."
echo

# mount

echo "Mounting ..."
LOOP_DEVICE=`losetup -f --show $FILE`
kpartx -va $LOOP_DEVICE
PART_BOOT="/dev/dm-0"
PART_ROOT="/dev/dm-1"
echo "Finish."
echo

# format

echo "Formating ..."
mkfs.vfat $PART_BOOT
mkfs.ext4 $PART_ROOT
echo "Finish."
echo

# backup prepare

MOUNT_POINT=/media/backup_$TIME/
if [ ! -d "$MOUNT_POINT" ];then
  mkdir $MOUNT_POINT
fi

# backup /dev/boot

echo "Backing up disk /dev/boot ..."
mount -t vfat $PART_BOOT $MOUNT_POINT
cp -rfp /boot/* $MOUNT_POINT
umount $MOUNT_POINT
echo "Finish."
echo

# backup /dev/root

echo "Backing up disk /dev/root ..."
mount -t ext4 $PART_ROOT $MOUNT_POINT
cd $MOUNT_POINT
dump -h 0 -0uaf - / | sudo restore -rf -
cd
umount $MOUNT_POINT
echo "Finish."
echo

# unmount

echo "Unmounting ..."
kpartx -vd $LOOP_DEVICE
losetup -d $LOOP_DEVICE
rm -fr $MOUNT_POINT
echo "Finish."
echo

# end

echo "Back-up image $FILE is successfully created."
echo
```

# 收藏！最简单的树莓派系统备份方法！

最近这段时间，第一次买了树莓派4B玩，主要用来做机器人控制。往树莓派系统里面配置了各种环境，花了不少时间，包括很烦人的opencv-python。因此，把这个系统备份一下，是很有必要的，避免以后重复配置环境，徒增工作量。

**0.温馨提示**

不要用拼多多上买的那种十几块钱就有32G容量的SD卡，这些卡很多都是有问题的，写入镜像后你会发现树莓派无法启动。建议用正规的SD卡，比如淘宝上写着支持树莓派的闪迪SD卡，就没什么问题。因此，当你照着下面方法写入的系统无法启动时，可以考虑是否SD卡存在问题！

假若你的树莓派系统装在A卡中，备份树莓派系统，有两种方案：

**1.拷贝整张卡**

将A卡中的系统，直接用dd命令按字节拷贝到B卡中。其中B卡容量必须比A卡大，因为dd命令是直接把A卡中的全部内容拷贝到B卡中。（比如你的A卡是16G，那么B卡必须大于16G，即32G）。

将A卡作为系统卡启动树莓派，B卡通过读卡器插到树莓派。

则你的A卡一般是：/dev/mmcblk0， B卡可能是/dev/sdb（根据实际情况修改），则执行以下命令即可：

```bash
sudo dd bs=4M of=/dev/mmcblk0 if=/dev/sdb
```

拷贝整张卡的方式，还可以通过windows系统来做，但这时候需要Win32DiskImager这个工具，网上很多博客介绍这种方式，这里就不写了。

**2.拷贝系统分区**

第1种方法虽然简单，但是最大缺点就是浪费SD卡容量，要求你的B卡必须比A卡容量大，很不友好！

可以在这个github项目下载根据系统分区制作树莓派镜像的脚本：

https://link.zhihu.com/?target=https%3A//github.com/BigBubbleGum/RaspberryBackup

具体脚本内容无需理会，反正很好用！随便找一个linux系统，下载好该脚本，赋予改脚本执行权限：

```bash
sudo chmod +x rpi-backup.sh
```

然后通过读卡器，将存有树莓派系统的A卡插进去。查看A卡系统分区：

```bash
df -h
```

可以看到A卡的系统分区：

![](https://pic3.zhimg.com/80/v2-c4c23272f436bf0716f7f21bc3395b7e_720w.jpg)

然后执行：

```bash
sudo bash rpi-backup.sh /dev/sdb1 /dev/sdb2
```

执行脚本时，后面跟着两个参数，第一个参数是树莓派SD卡/boot分区的设名：/dev/sdb1，第二个参数是根目录分区的设备名：/dev/sdb2，注意依据实际情况修改！

执行完后，可以在~/backupimg/目录下，看到一个xxxxxxxx.img镜像文件。

你可以查看这个镜像文件，发现它很小，应该只有几个G。以后，当你需要使用这个系统时，再用dd命令将这个镜像写入SD卡即可。比如你想把这个镜像写入B卡，通过下列命令查看B卡设备名：

```bash
df -h
```

发现B卡可能对应着/dev/sdb1，甚至对应着/dev/sdb1和/dev/sdb2两个分区。

但是它几个分区都无所谓，我们用dd命令写入镜像时，直接写/dev/sdb即可。在这之前，需要先卸载一下SD卡，避免写镜像时同时被其他进程写入：

```bash
sudo umount /dev/sdb1
```

若有两个分区，则：

```bash
sudo umount /dev/sdb1
sudo umount /dev/sdb2
```

最后利用dd命令完成镜像写入：

```bash
 sudo dd bs=4M of=xxxxxxx.img if=/dev/sdb
```

此时，linux终端就只有一个光标，看上去卡住了，不用管，等待其写完即可！

最后将写入镜像的SD卡插在树莓派上，就可以开始玩了。

# 

# 树莓派无显示器和网线配置

# 需要的设备

树莓派一个 
sd卡 16g以上

# 关于系统

系统推荐使用官方系统

# 安装系统

下载好系统后，解压！找到sd卡，用Diskimager把系统写入到sd卡中。

![img](Pic_Source/18984220-f550275b22809d17.png)

其实就是安顺序点击（2）、（3）、（5）

## 配置ssh

在系统没有开启SSH服务的情况下，sd卡根目录建立ssh（无任何后缀）文件可以在开机打开ssh服务。但是在关机重启后ssh服务是失效的，因为一次启动会删除根目录的ssh文件，除非每次上电之前重建。

因此为了使用SSH，第一次进入后在raspi-config中开启ssh服务。

**5.连接树莓派**  
路由器中发现树莓派设备后，可以使用**powershell中尝试ping树莓派的ip地址**  
ping通后，在powershell中**使用命令ssh pi@ip_addr进行远程访问树莓派，其中pi是树莓派OS默认用户名**  
输入**pi的密码，默认为：raspberry**，即可远程登陆树莓派

**注：**

**输入密码时，不会有字符或光标提示**

**通过ssh远程访问树莓派可以使用putty，windows powershell，cmd等等。**

## 配置WiFi

用户可以在未启动树莓派的状态下单独修改 `/boot/wpa_supplicant.conf` 文件配置 WiFi 的 SSID 和密码，这样树莓派启动后会自行读取 wpa_supplicant.conf 配置文件连接 WiFi 设备。

操作方法简单：将刷好 Raspbian 系统的 SD 卡用电脑读取。在 boot 分区，也就是树莓派的 `/boot` 目录下新建 wpa_supplicant.conf 文件，按照下面的参考格式填入内容并保存 wpa_supplicant.conf 文件。

```python
country=CN
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1
network={
ssid="WiFi-A"
psk="12345678"
key_mgmt=WPA-PSK
priority=1
}
network={
ssid="WiFi-B"
psk="12345678"
key_mgmt=WPA-PSK
priority=2
scan_ssid=1
}
```

```
说明以及不同安全性的 WiFi 配置示例：
#ssid:网络的ssid
#psk:密码
#priority:连接优先级，数字越大优先级越高（不可以是负数）
#scan_ssid:连接隐藏WiFi时需要指定该值为1
```

如果你的 WiFi 没有密码

```python
network={
ssid="你的无线网络名称（ssid）"
key_mgmt=NONE
}
```

如果你的 WiFi 使用WEP加密

```python
network={
ssid="你的无线网络名称（ssid）"
key_mgmt=NONE
wep_key0="你的wifi密码"
}
```

如果你的 WiFi 使用WPA/WPA2加密

```python
network={
ssid="你的无线网络名称（ssid）"
key_mgmt=WPA-PSK
psk="你的wifi密码"
}
```

# 上电启动

树莓派的初始用户名是pi，密码是raspberry。

## 树莓派更换软件源

软件源在线配置工具已上线，一键生成更新命令，再也不用手打指令啦

[树莓派软件源在线配置工具]([电气罐头 ⚡️](https://tech.biko.pub/tool#/rpi-apt-sources))

![](https://pic3.zhimg.com/80/v2-ddecb9a1bd2ab6688aee7b90577bd3da_720w.jpg)

---

在开始树莓派的各种 DIY 之前，我们还需要做一件很重要的事情：**更换软件源**。

这里我简单解释下什么是软件源，以及为什么要更换软件源。

软件源是指 debian 系操作系统的应用程序安装包仓库，很多的软件都会这收录到这个仓库里面。而树莓派的 raspberrypi 操作系统也是基于 debian 的，所以树莓派也有自己的软件源，用来收录各种树莓派应用程序。

默认情况下，树莓派软件源地址是 [http://archive.raspbian.org/]，位于欧洲，在国内访问是非常慢的，经常只有几 k 每秒的下载速率。所以我们在玩转树莓派之前，强烈推荐替换成国内的软件源。

树莓派的所有软件源地址可以从这里找到：[https://www.raspbian.org/RaspbianMirrors]

一般我们找个国内的就行了，比如清华大学的（下图表格的第一行）

![](https://pic4.zhimg.com/80/v2-304cc3dcc77eee67a0f24fad431ddf27_720w.jpg)

## 更换软件源

命令行执行 

`sudo nano /etc/apt/sources.list` 

> sudo 是指用系统管理员权限启动，nano 是树莓派内置的轻量文本编辑器，而 /etc/apt/sources.list 就是软件源的配置文件地址了。

```python
deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib
deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib
```

命令行执行：

`sudo nano /etc/apt/sources.list.d/raspi.list` 

文件也替换成下面的内容：

```python
deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui
```

执行 

`sudo apt-get update & upgrade`

进行更新和安装。

## 开启vnc

我这个树莓派版本会带非常多的软件，比如vnc。我觉得vnc还是挺好用的，树莓派桌面很骚气，我喜欢。一直用ssh看着心累。但是开启vnc需要一些步骤。

1. 打开raspi-config。在ssh界面直接输入`sudo raspi-config`即可

2. 在ssh界面直接输入
   
   ```text
   vncserver
   ```
   
   然后可以在电脑或者手机端下载vncviewer
   
   新建一个账户，输入你的ip+1

> 此处的1代表vncserver的第一个服务，与之前我们输入vncserver后产生的日志一致。如果你开启了多个vncserver，请输入你想连的服务。其实就是最后一行ip后面的那个数字

之后双击，输入用户名密码，就可以用vnc登陆树莓派了！

默认用户名密码与ssh一致

# 如何设置树莓派 VNC 的分辨率

当我们[使用 VNC 连接到树莓派](https://shumeipai.nxez.com/2018/08/31/raspberry-pi-vnc-viewer-configuration-tutorial.html)时，默认的分辨率非常低。甚至无法显示整个桌面，因此我们需要对分辨率进行设置。
在树莓派上设置 VNC 的分辨率很简单，在终端运行下面指令进入设置界面设置。

```
sudo raspi-config
```

按照下面的顺序选择 Advanced Options > Resolution，最后选择一个更合适的分辨率并确认完成即可。

建议在设置完成后重启树莓派或重新启动 VNC 服务让设置生效。

# 用Windows远程桌面连接树莓派的方法

树莓派DIY笔记之前有介绍过用VNC连接到树莓派的方法。在Windows下，当然还是自带的远程桌面更便捷。如果不想用VNC，利用远程桌面（mstsc.exe）连接树莓派，如何实现？

只需要在raspbian下面安装一个服务xdrp即可。输入如下命令安装：

```text
sudo apt-get install xrdp
```

然后就Ok了。

![20131006224911821-0](Pic_Source/20131006224911821.jpg)

![20131006224911925-0](Pic_Source/20131006224911925.jpg)

**2018.1.22 更新：**
如果出现报错 error – problem connecting，问题根源在于tightvnc，出现问题的版本跟X字体有冲突，导致连接Xserver出错。
解决方法：

```text
sudo apt-get purge tightvnc xrdp
sudo apt-get install tightvncserver xrdp
```

最后启动 xrdp 服务，

```text
sudo /etc/init.d/xrdp restart
```

此时会启用相应端口，配置方面默认即可。
通过命令：netstat -tnl
查看 3350 3389 5910 这三个端口处于LISTEN，一般就没问题了。
dpkg -L + 软件包的名字，可以知道这个软件包包含了哪些文件。

# 树莓派之使用OLED屏幕显示系统ip等其他信息

------

### 1.启动树莓派的I2C功能

```text
sudo apt-get install -y python-smbus
sudo apt-get install -y i2c-tools
sudo raspi-configtext
```

### 2.安装Adafruit-SSD1306库

Adafruit-SSD1306库是基于Python的OLED库，可以用于１２８＊６４，１２８＊３２像素SSD1306芯片控制的屏幕

```text
sudo python -m pip install --upgrade pip setuptools wheel
```

如果这一步出错，八成是pip的问题，这时候我们可以尝试卸载重新安装pip来解决！！！

```text
sudo apt-get remove python-pip python3-pip
sudo apt-get install python-pip python3-pip
```

然后重新运行上面的代码，一般就完成了！
安装PIL库,有一些图片处理的程序会用到这个。

```text
sudo apt-get install python-pil python3-pil
```

使用pip安装Adafruit-SSD1306库

```text
sudo pip install Adafruit-SSD1306
```

再下载一份包含代码示例的库后面用

```text
cd  ~
git clone https://github.com/adafruit/Adafruit-Python_SSD1306.git
```

> 如果上面pip安装Adafruit-SSD1306库遇到网络问题，那么也可以在下载这份代码之后运行下面的命令安装

```text
cd Adafruit_Python_SSD1306
sudo python setup.py install
```

进到示例目录，可以看到有一些已经准备好了的代码，后面将屏幕接好之后可以直接运行看效果。

```text
cd ~/Adafruit_Python_SSD1306/example/
```

### 3.连接屏幕

对于屏幕的接线，一定不要接错，树莓派引脚(所有树莓派４０针引脚都是这样排列，不需要因为不同版本而改动)如下图所示：

![img](Pic_Source/v2-b68a8cb147ddc5a01bfc6da451b925e1_720w.jpg)

　　　　　　　　　　　　　　　　　树莓派引脚ls

### 根据屏幕 PCB 上引脚的功能标注接到树莓派上对应的 GPIO 上即可。

屏幕 GND 接树莓派 GND
屏幕 VCC 接树莓派 3V3
屏幕 SDA 接树莓派 SDA
屏幕 SCL 接树莓派 SCL

> 注意一定不要接反 VCC 和 GND，否则会烧坏屏幕!!!

接上之后通过命令检测是否识别到i2c设备

```text
sudo i2cdetect -y 1
```

> 注意：如果上述命令不行的话可以使用如下命令

```text
sudo i2cdetect -y 0
```

### 4.编程和运行

我们可以先使用示例代码来进行快速上手，其中有一个文件名为stats.py的程序，用来显示树莓派的ip,cpuload,内存和磁盘的使用情况。我们先试一下这个程序。

```text
cd ~
sudo cp ~/Adafruit_Python_SSD1306/examples/stats.py ~/
sudo nano stats.py
```

```python
disp = Adafruit_SSD1306.SSD1306_128_64(rst=RST,i2c_bus=3)
```

现在我们需要实际所需的参数来进行修改，例如SSD1306_128_32代表128*32的分辨率屏幕的初始化方法(一般都是１２８＊６４)，。i2c_address用于配置屏幕的地址，默认为０ｘ３ｃ。
运行示例代码，可看到运行效果。

```text
sudo python stats.py
```

在代码中可以读取其他的信息，假如加上读取ＣＰＵ温度，代码如下：

```text
sudo nano stats.py
```

```python
＃在空白地方创建一个函数：
def get_cpu_temp():
  tempfile = open('/sys/class/thermal/thermal_zone0/temp')
  cpu_temp = tempfile.read()
  tempfile.close()
  return float(cpu_temp)
```

然后在while循环里添加一句

```python
draw.text((x, top+35), "Temp: "+str(get_cpu_temp(), font=font, fill=255)　
```

屏幕上的图片、形状、文本和字体都是由 PIL（Python Imaging Library）的模块 Image, ImageDraw, and ImageFont 来实现的。如有兴趣可以试试其他代码示例，并学习自己设计图文来显示。

#### python获得MAC

方法一：（不靠谱）

```python
def get_mac_address(self):
    import uuid
    mac=uuid.UUID(int = uuid.getnode()).hex[-12:].upper()
    return '%s:%s:%s:%s:%s:%s' % (mac[0:2],mac[2:4],mac[4:6],mac[6:8],mac[8:10],mac[10:])

##    return ":".join([mac[e:e+2] for e in range(0,11,2)])
```

方法二：

```python
　　#按操作系统平台来：

def get_mac_address():
  '''
  @summary: return the MAC address of the computer
  '''
  import sys
  import os
  mac = None
  if sys.platform == "win32":
    for line in os.popen("ipconfig /all"):
      print line
      if line.lstrip().startswith("Physical Address"):
        mac = line.split(":")[1].strip().replace("-", ":")
        break
  else:
    for line in os.popen("/sbin/ifconfig"):
      if 'Ether' in line:
        mac = line.split()[2]#需要调整
        break
  return mac
```

```text
sudo reboot
```

### 5.设置开机运行

修改/etc/rc.local文件

```python
sudo nano /etc/rc.local
```

在exit 0前面增加一行：

```python
sudo python /home/pi/stats.py &
```

### 6.提高显示速率（不推荐）

为了更好地显示性能，例如显示动画时对帧率有要求，可以通过修改下面的参数将i2c频率从默认的１００khz提升到１mhz．

```python
sudo nano /boot/config.txt
```

在文末添加一行：

```python
dtparam=i2c_baudrate=1000000
```

# 用GPIO虚拟I2C

修改 /boot/config.txt

```tsx
dtoverlay=i2c-gpio,bus=3,i2c_gpio_delay_us=2,i2c_gpio_sda=5,i2c_gpio_scl=6
```

运行i2cdetect -l，出现了i2c-3设备：

```
root@raspberrypi:/home/pi# i2cdetect -l
i2c-3  i2c       i2c@3                  I2C adapter
i2c-1  i2c       bcm2835 I2C adapter           I2C adapter
```

运行i2cdetect -y 3，找到6wd：

```
root@raspberrypi:/home/pi# i2cdetect -y 3
    0 1 2 3 4 5 6 7 8 9 a b c d e f
00: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
40: -- 41 -- -- -- -- -- -- -- -- -- -- -- -- -- --
50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
70: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
```

其中 i2c_gpio_sda=5 和 i2c_gpio_scl=6 分别指 pin 29 和 pin 31。

# 树莓派配置开关机键

其实 /boot/overlays/README 里面详细介绍，只要在 /boot/config.txt 中添加相关配置就能实现关机。

修改 /boot/config.txt

```tsx
dtoverlay=gpio-shutdown
```

使用GPIO3（这里的GPIO指3BCM GPIO编号，也就是SCL1）作为电源键，下降沿为按下，上升沿为弹起，内部上拉 

保存并重启，之后你只需要在GPIO3（这里的GPIO指3BCM GPIO编号，也就是SCL1）和GND之间接个按键就能实现关机，正常关机后不切断树莓派电源，将GPIO3拉到低电平就能开机！

开始划重点！！

前面提到的配置默认使用GPIO3，也就是SCL1作为电源键，SCL1是I2C硬件接口引脚，在i2c功能打开的情况下，SCL1被I2C占用，是不能实现关机功能的，只能作为开机键使用。并且目前还没有找到自定义其他口开机的方法，开机必须的使用GPIO3进行开机。关机功能可以使用gpio_pin=17，即GPIO_0（物理引脚PIN_11）做关机键 。

修改/boot/config.txt：

```
dtoverlay=gpio-shutdown,gpio_pin=17,active_low=1,gpio_pull=up
```

**合理解决方案**
此方案基于GPIO17用于关机键，使用GPIO3作为开机键，但只需要一个开关按键。
大概原理图：![img](Pic_Source/20210220123214791.png)

当按键按下时，标记2（即GPIO17）变为低电平，实现关机功能；
当再次按下按键，标记2（即GPIO17）变为低电平，左边三极管导通致使右边三极管导通，使标记1（即GPIO3）变为低电平，实现开机功能。
正常时候，按键未按下时，不影响GPIO3的使用，还可正常作为I2C功能或者其它功能使用。
配合以下配置，实测OK，开关机功能正常，且硬件I2C功能正常使用。

使用GPIO17（即序号为11的）做关机键

dtoverlay=gpio-shutdown,gpio_pin=17,active_low=1,gpio_pull=up
下面的实际测试的照片，上面的按键PCB原来走的就是GPIO17：

**粗暴一点的方案**

直接短接GPIO3和GPIO17，测试可行！

# 树莓派GPIO

![img](Pic_Source/2018102716151630.png)

#### Nano中显示行号

无意中发现了漂亮的快捷键：Alt + Shift + 3。

![nano,ubuntu](https://ubuntuqa.com/wp-content/uploads/2018/03/abee06c9ab8ee2a7fa12ea68347e9ef1.jpg)

## 二、查看树莓派后台线程

1.打开终端输入 ps aux 查看所有的进程

```
ps aux
```

2.或者打开终端输入 ps -ef | grep python 查看python的进程

```
ps -ef | grep python
```

# 树莓派摄像头Camera的使用

### 一、安装

#### 1.硬件安装

![img](Pic_Source/14270006-ee9c11ce9603c542.png)

#### 2.打开Raspberry Pi配置工具开启Camera

![img](Pic_Source/14270006-4d6bd5ff004bb2d1.png)

![img](Pic_Source/14270006-40180350bdc71b21.png)

### 二、 如何通过命令行控制摄像头模块

> 现在您的相机模块已连接且软件已启用，请尝试使用命令行工具`raspistill`和`raspivid`。

#### 1.单击任务栏中的黑色监视器图标打开终端窗口：

![img](Pic_Source/14270006-955165a8d6c83196.png)

打开终端

#### 2.键入以下命令以拍摄静态图片并将其保存到桌面：

```python
raspistill -o Desktop/image.jpg
```

![img](Pic_Source/14270006-30159655419397c1.png)

raspistill命令进入终端

#### 3.按`Enter`运行命令。

当命令运行时，您可以在拍摄静止图像之前看到相机预览打开五秒钟。

#### 4.在桌面上查找图片文件图标，然后双击文件图标以打开图片。

![img](Pic_Source/14270006-e95e79353b70563a.png)

桌面上的图像

> 通过添加不同的选项，您可以设置`raspistill`命令所采用的图像的大小和外观。
> 
> - 例如，添加`-h`和`-w`更改图像的高度和宽度：

```python
raspistill -o Desktop/image-small.jpg -w 640 -h 480
```

> - 现在使用以下`raspivid`命令使用Camera Module录制视频：

```python
raspivid -o Desktop/video.h264
```

> - 要播放视频文件，请双击`video.h264`桌面上的文件图标以在VLC Media Player中将其打开。

### 三、如何使用Python代码控制相机模块

**Python `picamera`库允许您控制相机模块并创建出色的项目。**

#### 1.打开Python 3编辑器，例如**Thonny Python IDE**：

![img](Pic_Source/14270006-6074bdc1bf16cf73.png)

打开Thonny

#### 2. 打开一个新文件并将其另存为`camera.py`。

**注意：** **永远不要将文件保存为`picamera.py`**，这一点很重要。

#### 3.输入以下代码：

```python
from picamera import PiCamera
from time import sleep

camera = PiCamera()

camera.start_preview()
sleep(5)
camera.stop_preview()
```

#### 4.* 保存并运行您的程序。相机预览应显示五秒钟，然后再次关闭。

![img](Pic_Source/14270006-56f524cf4c8b745f.jpg)

图像预览

> **注意：**只有将显示器连接到Raspberry Pi时，相机预览才有效。如果您使用远程访问（例如SSH或VNC），则不会“看到相机预览”。

#### 5.如果您的预览是颠倒的，可以使用以下代码将其旋转180度：

```python
camera = PiCamera()
camera.rotation = 180
```

> 您可以通过旋转图像`90`，`180`或`270`度。要重置图像，请设置`rotation`为`0`度。

> 最好使预览稍微透视，以便在预览打开时查看程序中是否出现错误。

#### 6.通过设置`alpha`级别使相机预览透视：

```python
camera.start_preview(alpha=200)
```

> 该`alpha`值可以是`0`和`255`之间的任何数字。

### 四、用Python代码拍摄静态图片

> 现在使用相机模块和Python拍摄一些静态照片。

##### 1.修改您的代码以添加camera.capture()一行：

```python
camera.start_preview()
sleep(5)
camera.capture('/home/pi/Desktop/image.jpg')
camera.stop_preview()
```

> **注意**：sleep在拍摄图像之前至少需要两秒钟，这一点非常重要，因为这样可以让相机的传感器有时间感应光线。
> 运行代码。
> 您应该看到相机预览打开五秒钟，然后应该拍摄静止图像。拍照时，您可以看到预览会短暂调整到不同的分辨率。
> 您的新图像应保存到桌面。

##### 2.现在添加一个循环来连续拍摄五张照片：

```python
camera.start_preview()
for i in range(5):
    sleep(5)
    camera.capture('/home/pi/Desktop/image%s.jpg' % i)
camera.stop_preview()
```

> 变量i计算多少次循环运行后，从0到4。因此，图像将保存为image0.jpg，image1.jpg等等。
> 再次运行代码并将摄像头模块固定到位。
> 相机应该每五秒拍一张照片。拍摄完第五张照片后，预览将关闭。
> 查看桌面以查找五张新图片。

### 五、使用Python代码录制视频

> 现在录制视频

##### 1.修改您的代码以删除capture()并改为添加start_recording()和stop_recording()

> 您的代码现在应该如下所示：

```python
camera.start_preview()
camera.start_recording('/home/pi/Desktop/video.h264')
sleep(5)
camera.stop_recording()
camera.stop_preview()
```

> 运行代码。
> 您的Raspberry Pi应该打开预览，录制5秒的视频，然后关闭预览。

### 六、如何更改图像设置和添加图像效果

> Python `picamera`软件提供了许多效果和配置来改变图像的外观。
> **注意：**某些设置仅影响预览而不影响捕获的图像，某些设置仅影响捕获的图像，而其他许多设置仅影响两者。

##### 1.设置图像分辨率

> 您可以更改`resolution`相机模块拍摄的图像。
> 默认情况下，图像分辨率设置为显示器的分辨率。静态照片的最大分辨率为2592×1944，视频录制的最大分辨率为1920×1080。

> - 使用以下代码将`resolution`最大值设置为拍照。

> **注意：**您还需要将帧速率设置`15`为启用此最大分辨率。

```python
camera.resolution = (2592, 1944)
camera.framerate = 15
camera.start_preview()
sleep(5)
camera.capture('/home/pi/Desktop/max.jpg')
camera.stop_preview()
```

> 最低分辨率为64×64。

##### 2.在图片中添加文字

> 您可以使用该命令向图像添加文本`annotate_text`。

> - 运行此代码尝试：

```python
camera.start_preview()
camera.annotate_text = "Hello world!"
sleep(5)
camera.capture('/home/pi/Desktop/text.jpg')
camera.stop_preview()
```

##### 3.更改添加文本的外观

> - 使用以下代码设置文本大小：

```python
camera.annotate_text_size = 50
```

> 您可以将文本大小设置为之间的任何东西`6`来`160`。默认大小是`32`。
> 也可以更改文本颜色。

> - 首先，添加`Color`到`import`程序顶部的行：

```python
from picamera import PiCamera, Color
```

> - 然后`import`在行下面修改你的其余代码，使它看起来像这样：

```python
camera.start_preview()
camera.annotate_background = Color('blue')
camera.annotate_foreground = Color('yellow')
camera.annotate_text = " Hello world "
sleep(5)
camera.stop_preview()
```

##### 4.更改预览的亮度

> 您可以更改预览显示的亮度。默认亮度为`50`，您可以将其设置为`0`和之间的任何值`100`。

> - 运行以下代码试试这个：

```python
camera.start_preview()
camera.brightness = 70
sleep(5)
camera.capture('/home/pi/Desktop/bright.jpg')
camera.stop_preview()
```

> - 以下循环调整亮度并添加文本以显示当前亮度级别：

```python
camera.start_preview()
for i in range(100):
    camera.annotate_text = "Brightness: %s" % i
    camera.brightness = i
    sleep(0.1)
camera.stop_preview()
```

##### 5.更改预览的对比度

> 与预览亮度类似，您可以更改预览的对比度。

> - 运行以下代码试试这个：

```python
camera.start_preview()
for i in range(100):
    camera.annotate_text = "Contrast: %s" % i
    camera.contrast = i
    sleep(0.1)
camera.stop_preview()
```

##### 6.添加炫酷的图像效果

> 您可以使用它`camera.image_effect`来应用特定的图像效果。

> 图像效果选项包括：

- `none`
- `negative`
- `solarize`
- `sketch`
- `denoise`
- `emboss`
- `oilpaint`
- `hatch`
- `gpen`
- `pastel`
- `watercolor`
- `film`
- `blur`
- `saturation`
- `colorswap`
- `washedout`
- `posterise`
- `colorpoint`
- `colorbalance`
- `cartoon`
- `deinterlace1`
- `deinterlace2`

> 默认效果是`none`。

> - 选择图像效果并尝试一下：

```python
camera.start_preview()
camera.image_effect = 'colorswap'
sleep(5)
camera.capture('/home/pi/Desktop/colorswap.jpg')
camera.stop_preview()
```

> - 运行此代码以循环**所有**图像效果`camera.IMAGE_EFFECTS`：

```python
camera.start_preview()
for effect in camera.IMAGE_EFFECTS:
    camera.image_effect = effect
    camera.annotate_text = "Effect: %s" % effect
    sleep(5)
camera.stop_preview()
```

![img](Pic_Source/14270006-d8195be2534b75ba.jpg)

效果

##### 设置图像曝光模式

您可以使用`camera.exposure_mode`将曝光设置为特定模式。

曝光模式选项包括：

- `off`
- `auto`
- `night`
- `nightpreview`
- `backlight`
- `spotlight`
- `sports`
- `snow`
- `beach`
- `verylong`
- `fixedfps`
- `antishake`
- `fireworks`

默认模式是`auto`。

- 选择曝光模式并试用：

```python
camera.start_preview()
camera.exposure_mode = 'beach'
sleep(5)
camera.capture('/home/pi/Desktop/beach.jpg')
camera.stop_preview()
```

- 您可以`camera.EXPOSURE_MODES`像使用图像效果一样遍历所有曝光模式。

### 7.更改图像白平衡

> 您可以使用`camera.awb_mode`将自动白平衡设置为预设模式。

> 可用的自动白平衡模式为：

- `off`
- `auto`
- `sunlight`
- `cloudy`
- `shade`
- `tungsten`
- `fluorescent`
- `incandescent`
- `flash`
- `horizon`

> 默认是`auto`。

> - 选择自动白平衡模式并尝试：

```python
camera.start_preview()
camera.awb_mode = 'sunlight'
sleep(5)
camera.capture('/home/pi/Desktop/sunlight.jpg')
camera.stop_preview()
```

> - 您可以`camera.AWB_MODES`像使用图像效果一样循环所有自动白平衡模式。

![子豪兄教你在树莓派上安装OpenCV](Pic_Source/v2-5afaaee448fd1a458de34cd33c3f027e_1440w.jpg)

# 子豪兄教你在树莓派上安装OpenCV

> 本文介绍了如何在树莓派上安装分别运行在Python2和Python3的OpenCV。
> 运行在Python2上的OpenCV安装非常简单，几行命令即可搞定。运行在Python3上的OpenCV安装比较麻烦，需要编译安装，不用担心，本文默认你是新手小白，会一步步指导你安装。本教程经过作者亲自测试，自认为是全网最靠谱的相关教程。
> 原创作者：同济大学开源软件协会 [子豪兄Tommy](https://link.zhihu.com/?target=https%3A//github.com/TommyZihao) 微信公众号：子豪兄的科研小屋
> 转载或复制请以 [原文超链接形式](https://link.zhihu.com/?target=https%3A//github.com/TommyZihao/Zihao-Blog/blob/master/%E5%AD%90%E8%B1%AA%E5%85%84%E6%95%99%E4%BD%A0%E5%9C%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A%E5%AE%89%E8%A3%85OpenCV.md) 并注明出处 [子豪兄](https://link.zhihu.com/?target=https%3A//github.com/TommyZihao)。
> 原文地址 [http://suo.im/5gS6if](https://link.zhihu.com/?target=http%3A//suo.im/5gS6if) 发布于2018-10-05

![img](Pic_Source/v2-440b83a7e308a21835a3342bdea6341f_720w.jpg)

 OpenCV是程序员钟爱的开源计算机视觉库，拥有强大的内置函数和开源社群。OpenCV配合便携开源廉价的树莓派，可以直接读取来自树莓派摄像头PiCamera的视频，进行人脸识别、边缘检测、语义分割、自动驾驶、图像识别等各种计算机视觉开发。很多优秀开源项目，比如谷歌人工智能框架[Tensorflow](https://link.zhihu.com/?target=https%3A//github.com/tensorflow/tensorflow)和人脸识别开源项目[face_recognition](https://link.zhihu.com/?target=https%3A//github.com/TommyZihao/face_recognition/blob/master/README_Simplified_Chinese.md)，都需要安装OpenCV作为运行前提。不少本科生的毕业设计也要用到它。

用OpenCV或SimpleCV可以实现丰富的机器视觉应用（人脸识别、边缘检测、颜色分割、物体识别、手写字体识别、二维码识别、车道检测、运动检测），更多案例请关注本教程后续章节。

 网上关于在树莓派上安装OpenCV的教程很多，老外写的和中国人写的都有，但都**很不靠谱**，经过长达7个月的摸索、屡败屡战的尝试，作者终于找到了靠谱的安装流程，并总结成本文。所有过程亲测有效。

 运行在Python2上的OpenCV安装非常简单，几行命令即可搞定。运行在Python3上的OpenCV安装比较麻烦，需要编译安装。**作者建议两个都安装**。不用担心，本文默认你是新手小白，会一步步指导你安装。本教程经过作者亲自测试，自认为是全网最靠谱的相关教程。

 按照本教程安装好之后，你可以迅速上手用树莓派做一个[子豪兄教你用树莓派做人脸识别](https://link.zhihu.com/?target=https%3A//github.com/TommyZihao/Zihao-Blog/blob/master/%E5%AD%90%E8%B1%AA%E5%85%84%E6%95%99%E4%BD%A0%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E5%81%9A%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB.md)。

![img](Pic_Source/v2-500bdcc732946b027292d0f85a885bdc_b.jpg)

## 安装前提

## 1.配置好树莓派的Raspbian操作系统

本教程使用的系统是2018年6月27日树莓派官方发布的Raspbian-stretch操作系统，[官方下载链接](https://link.zhihu.com/?target=https%3A//www.raspberrypi.org/downloads/raspbian/)。

纯新手小白可以参考我写的这两篇文章，从拆盒子到各项配置完毕的树莓派教程。

[子豪兄树莓派系列教程01:树莓派开机教程](https://link.zhihu.com/?target=https%3A//github.com/TommyZihao/Zihao-Blog/blob/master/01%E6%A0%91%E8%8E%93%E6%B4%BE%E5%BC%80%E6%9C%BA%E6%95%99%E7%A8%8B.md)

[子豪兄树莓派系列教程02:一劳永逸配置树莓派](https://link.zhihu.com/?target=https%3A//github.com/TommyZihao/Zihao-Blog/blob/master/02%E4%B8%80%E5%8A%B3%E6%B0%B8%E9%80%B8%E9%85%8D%E7%BD%AE%E6%A0%91%E8%8E%93%E6%B4%BE.md)

## 2.切换到国内的apt-get下载源和pip下载源

防止下载速度过慢。

不会换源的新手小白可以参考这篇文章[一劳永逸配置树莓派](https://link.zhihu.com/?target=https%3A//github.com/TommyZihao/Zihao-Blog/blob/master/02%E4%B8%80%E5%8A%B3%E6%B0%B8%E9%80%B8%E9%85%8D%E7%BD%AE%E6%A0%91%E8%8E%93%E6%B4%BE.md)。

## 3.如果你有树莓派官方的摄像头Picamera，需按如下方法正确配置

> 如果没有官方摄像头，也不影响安装

![img](Pic_Source/v2-4a7a8570fc80c9815b88ccf780f8b1a5_720w.jpg)

在命令行输入以下命令，这个命令的意思是用nano编辑器打开modules这个文件：

```text
sudo nano /etc/modules
```

在这个文件末尾添加一行

```text
bcm2835-v4l2
```

也就是这个效果

![img](Pic_Source/v2-39a2f650e88c239f414840226c9717fc_720w.jpg)

先按键盘上的`ctrl`+`o`，再按回车保存，再按`ctrl`+`x`退出nano编辑器回到命令行界面。

输入命令

```text
vcgencmd get_camera
```

如果得到下面的结果，则证明摄像头连接成功

![img](Pic_Source/v2-ec150a902f76e51047791b899f44f8a2_720w.jpg)

可以输入命令

```text
raspistill -o image.jpg
```

调用摄像头拍一张照片，命名为image.jpg，存储在/pi/home路径，也就是桌面左上角资源管理器一打开显示的那个路径。如果能看到摄像头上红灯亮，目录里面有照片，则进一步说明摄像头配置正确。

## 在树莓派安装运行在Python2上的OpenCV

## 1、安装

打开树莓派的命令行界面，两个命令即可完成安装。执行第一条命令需要半个小时左右，请耐心等待。第二条命令执行只需要几秒钟。

> 子豪兄友情提示：
> 建议第一个命令用树莓派桌面上自带的命令行工具运行，而不要使用远程ssh连接。因为执行命令时间太长，中途如果ssh断线的话无法得知是否已经安装完毕。

```text
sudo apt-get install libopencv-dev
sudo apt-get install python-opencv
```

## 2、在Python2上测试OpenCV

安装好之后，在命令行中输入`python`或者`python2`，回车

```python
import cv2
```

如果出现下图的结果，说明Python2环境下的OpenCV安装成功。

![img](Pic_Source/v2-f17ce91ece2f353eccce6057a622a032_720w.jpg)

也可以输入

```python
cv2.__version__
```

查看opencv版本号

![img](Pic_Source/v2-2fb408e1710ceeb6c8e8f33cc1d0b0ab_720w.jpg)

> 为啥叫cv2而不叫opencv呢？这是因为OpenCV是基于C/C++开发的，有两个版本，''cv”版本的API是C语言开发的，''cv2''版本的API是基于C++语言开发的，为了保持向后兼容性所以叫"cv2"，但我们都知道cv2就是OpenCV本尊。

也可以在桌面命令行里输入以下三个命令调用树莓派摄像头，把摄像头捕捉到的画面显示在桌面上，按`ctrl`+`c`键退出。

```text
git clone https://github.com/TommyZihao/opencvtest.git
cd opencvtest
python2 testopencv.py
```

![img](Pic_Source/v2-72eb596c714ef3aa229f2344c0e66633_720w.jpg)

## 在树莓派安装运行在Python3上的OpenCV

## 1、安装numpy

打开命令行界面，输入以下命令，安装Python科学计算库numpy

```text
sudo pip3 install numpy
```

## 2、在树莓派设置中把根目录扩大到整个SD卡

命令行界面输入命令，进入树莓派配置界面。用上下键和左右键切换光标位置。

```text
sudo raspi-config
```

![img](Pic_Source/v2-fef6aee22f97fca826dc726c69adf9d9_720w.jpg)

## 第七行：Advanced Options

![img](Pic_Source/v2-2ac5152f76cc06171e859dc7e7d80a5e_720w.jpg)

选择Expand Filesystem，将根目录扩展到这个SD卡，充分利用SD卡的存储空间。如果不进行这一步，后续命令会出现卡死。退出设置界面，重启树莓派。

```text
sudo reboot
```

## 3、安装OpenCV所需的库

挨个运行下面八条命令。共需要七分钟（注意倒数第三条命令中要安装四个-dev软件包）。

```text
sudo apt-get install build-essential git cmake pkg-config -y
sudo apt-get install libjpeg8-dev -y
sudo apt-get install libtiff5-dev -y
sudo apt-get install libjasper-dev -y
sudo apt-get install libpng12-dev -y
sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev -y
sudo apt-get install libgtk2.0-dev -y
sudo apt-get install libatlas-base-dev gfortran -y
```

## 4、下载OpenCV

在命令行输入以下三条命令，下载两个压缩包到树莓派的**/home/pi/Downloads**目录下。第一个压缩包86.8MB，第二个压缩包54.5MB：

```text
cd

wget https://github.com/Itseez/opencv/archive/3.4.0.zip

wget https://github.com/Itseez/opencv_contrib/archive/3.4.0.zip
```

> 如果下载速度很慢（比如每秒几个KB）：
> 方法1：可以在电脑浏览器中输入wget后面的链接下载压缩包，再用Fillzilla或者U盘等方法把文件传输到树莓派的**/home/pi/Downloads**目录下（一定不能错）。
> 方法2：:可以用电脑在[百度网盘链接](https://link.zhihu.com/?target=https%3A//pan.baidu.com/s/182NYJzW1nCpnQ7ftSYYuSw)下载这两个压缩包之后再用Fillzilla或者U盘等方法把文件传输到树莓派的**/home/pi/Downloads**目录下（一定不能错）。

解压这两个压缩包

```text
cd /home/pi/Downloads
unzip opencv-3.4.0.zip
unzip opencv_contrib-3.4.0.zip
```

## 5、设置编译参数

设置编译参数

```text
cd /home/pi/Downloads/opencv-3.4.0
mkdir build
cd build
```

设置CMAKE参数，注意，下面这是一行命令（包括最后那俩点儿），需要耐心等待十五分钟左右：

```text
cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local -D INSTALL_C_EXAMPLES=ON -D INSTALL_PYTHON_EXAMPLES=ON -D OPENCV_EXTRA_MODULES_PATH=/home/pi/Downloads/opencv_contrib-3.4.0/modules -D BUILD_EXAMPLES=ON -D WITH_LIBV4L=ON PYTHON3_EXECUTABLE=/usr/bin/python3.5 PYTHON_INCLUDE_DIR=/usr/include/python3.5 PYTHON_LIBRARY=/usr/lib/arm-linux-gnueabihf/libpython3.5m.so PYTHON3_NUMPY_INCLUDE_DIRS=/home/pi/.local/lib/python3.5/site-packages/numpy/core/include ..
```

根据下图判断你是否配置成功了CMAKE。如果失败，可能是因为两个压缩包的路径没有严格按照上文的要求。如果成功，就可以开始最重要的编译了。

<img src="Pic_Source/v2-8bd83f90e95a69a2cb7f4ac05eb00db2_720w.jpg" alt="img" style="zoom:200%;" />

## 6、编译

最后一步，也是最重要的一步：编译

保证树莓派有至少5G的存储空间，建议本命令用树莓派桌面上的命令行工具运行，而不要使用远程ssh连接。因为执行命令时间太长，中途如果ssh断线的话无法得知是否已经安装完毕。

```text
cd /home/pi/Downloads/opencv-3.4.0/build
make
```

![img](Pic_Source/v2-aba2a2c1a09a92e0288442c36774ad87_720w.jpg)

编译两个小时之后，完成了40%

![img](Pic_Source/v2-91dec070d6fa76aefe9d58e752ef7d42_720w.jpg)

静待五个小时的编译。注意，在此期间，树莓派要供电充足，不要运行其它任务，以免因为内存不够什么的幺蛾子报错。

![img](Pic_Source/v2-f6cb918cf9d2ecf0d340233096fdcd5b_720w.jpg)

## 错误处理：

```
~/opencv_contrib/modules/xfeatures2d/src/boostdesc.cpp:673:20: fatal error: boostdesc_bgm.i: No such file or directory
```

有效解决方法：

查看 build 文件夹下的日志文件 CMakeDownloadLog.txt，在日志文件CMakeDownloadLog.txt中搜索 boostdesc_bgm.i 关键词。日志文件里就有它的下载地址，到指定位置下载即可。https://github.com/opencv/opencv_contrib/issues/1301，点开上面这个网址往下拉，有人提供了缺失的各个文件的链接，点击保存. 或者直接在这个网页里搜索 BenbenIO 这个用户的回答。ps：中国访问被墙，所以无法自行获取到这个链接的资源，可以在后面的评论和解决方案中找到共享的打包文件下载这些需要的文件。

有效的操作就是：下载后，直接拷贝源码并生存同名文件，放在 **opencv_contrib/modules/xfeatures2d/src/** 路径下即可。（其他方法参考处理不达效果）

![img](Pic_Source/527375-20191101184949643-1539342230.png)

## 对于opencv2/xfeatures2d/cuda.hpp: No such file or directory 类问题的解决方法

```
/usr/local/arm/opencv-3.4.0/opencv_contrib-3.4.0/modules/xfeatures2d/include/opencv2/xfeatures2d.hpp:42:10: 
fatal error: /opencv2/xfeatures2d.hpp: No such file or directory
 #include "/opencv2/xfeatures2d.hpp"
          ^~~~~~~~~~~~~~~~~~~~~~~~~~
compilation terminated.
```

根据给的路径找到xfeature2d.hpp的文件并打开，找到第42行如下：

```
40 #ifndef __OPENCV_XFEATURES2D_HPP__
41 #define __OPENCV_XFEATURES2D_HPP__

42 #include"/opencv2/xfeatures2d.hpp"
```

改为绝对路径

```
40 #ifndef __OPENCV_XFEATURES2D_HPP__
41 #define __OPENCV_XFEATURES2D_HPP__

42#include"/usr/local/arm/opencv3.4.0/opencv_contrib3.4.0/modules/xfeatures2d/include/opencv2/xfeatures2d.hpp"
所有这种找不到的都这么解决。
```

对于boostdesc_bgm.i的问题直接下载到拟需要的文件夹。

```
opencv_contrib/modules/xfeatures2d/src/
```

百度云盘链接

链接：https://pan.baidu.com/s/1pv2P8jn14im9IUDGorIuFg 
提取码：2jnr 

`make`命令执行完成之后，执行下面的命令，执行命令需要一分钟：

```text
sudo make install
```

## 7、在Python3上测试OpenCV

安装好之后，在命令行中输入`python3`，回车

```python
import cv2
```

回车

```text
cv2.__version__
```

回车

如果出现下图的结果，说明Python3环境下的OpenCV安装成功。

![img](Pic_Source/v2-936ff21fc7711f99a86dd1f1b8845fc2_720w.jpg)

> 子豪兄批注：
> 我从2018年3月7日第一次尝试在树莓派上安装opencv，看了无数教程，历经无数次失败。有的教程要配置虚拟环境，有的要修改内存分配空间；有的教程使用树莓派四个cpu核心同时编译，每次都会报错；有的教程对新手小白极其不友好，完全不知该怎么操作。在七个月的努力成功之后，我想用我的血泪史书写本文，让每一个新手小白都能迅速上手而不是被bug卡到举目无亲。
> 本文会在未来继续更新和勘误，最新版以Github上的[子豪兄博客合集](https://link.zhihu.com/?target=https%3A//github.com/TommyZihao/Zihao-Blog)为准
> 转载或复制请以 [原文超链接形式](https://link.zhihu.com/?target=https%3A//github.com/TommyZihao/Zihao-Blog/blob/master/%E5%AD%90%E8%B1%AA%E5%85%84%E6%95%99%E4%BD%A0%E5%9C%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A%E5%AE%89%E8%A3%85OpenCV.md) 并注明出处 [子豪兄](https://link.zhihu.com/?target=https%3A//github.com/TommyZihao)。
> 原文地址 [http://suo.im/5gS6if](https://link.zhihu.com/?target=http%3A//suo.im/5gS6if) 发布于2018-10-05
> 同济大学开源软件协会
> 重庆大学树莓派爱好者俱乐部、人工智能协会、创新实践中心

## 树莓派python3使用pip3安装opencv3.4

安装环境：

  树莓派3B
  树莓派系统：buster
  python3.7
  opencv3.4
1.先使用 pip 直接安装：

```
sudo pip3 install opencv-python
```

  结果：网速太慢，下载超时报错

2.然后换清华大学的 pip 源继续安装：

```
sudo pip3 install opencv-python -i https://pypi.tuna.tsinghua.edu.cn/simple
```

 结果：仍然链接到国外的源，网速太慢，又超时报错

3.最后离线下载 whl 文件并传到树莓派上：

按照 pip 下载的链接复制到浏览器下载，网速依然很慢，不过下载成功了。

下载地址：https://www.piwheels.org/simple/opencv-python/opencv_python-3.4.3.18-cp37-cp37m-linux_armv7l.whl

    opencv_python-3.4.3.18-cp37-cp37m-linux_armv7l.whl (7.5MB)

在树莓派上离线安装：

```
sudo pip3 install opencv_python-3.4.3.18-cp37-cp37m-linux_armv7l.whl
```

6.依赖库总结

```
sudo apt-get install libatlas-base-dev

sudo apt-get install libjasper-dev

sudo apt-get install libqtgui4

sudo apt-get install libqt4-test

# 可能还需要安装下面的依赖

sudo apt-get install libhdf5-dev
```

# 树莓派实现简单的人脸识别

一个用树莓派做的会聊天，能人脸识别（支持云台追踪）和发送邮件的小玩具

https://blog.csdn.net/yonglisikao/article/details/82804318

前提
一.硬件要求
树莓派及基本配件，树莓派摄像头模块（Picamera）或USB摄像头（Webcam）。

二.系统要求
Raspbian系统（其他Linux系统应该也可以，没试过）

三.软件要求
Python及一些库——opencv，dlib， face_recognition，numpy

（安装opencv一般需要至少一个小时，如果使用Picamera，可以用更简单的picamera库代替，这些将在后文中继续讨论。）

环境搭建
1.系统安装
系统安装可以参考之前的文章。

2.摄像头配置
摄像头与树莓派在物理上连接完成后，如果是首次使用需要进行一些配置，在命令行输入：

```
sudo raspi-config
```

在 Interfacing Options 里启用 Camera，在命令行输入：

```
sudo reboot
```

配置完毕，接下进行检查，在命令行输入：

```
ls /dev/video*
```

如果有显示：/dev/video0，则检查完毕。

3.库的安装
安装opencv，参考下面这篇Adrian Rosebrock的文章：

https://www.pyimagesearch.com/2017/09/04/raspbian-stretch-install-opencv-3-python-on-your-raspberry-pi/

走完这篇文章的所有流程后，你应该安装了numpy，并建立了自己的虚拟环境（virtualenv），无论它叫 cv 或者其他什么名字的，以下的操作请都在虚拟环境下完成。另外，我使用的是python3。

安装dlib，face_recognition，在命令行输入：

```
pip install dlib
pip install face_recognition
pip install numpy
```

至此环境搭建完毕。

代码实现
1.face_recognition库的简单使用
face_recognition的github项目地址为：https://github.com/ageitgey/face_recognition

在此仅简单介绍几个函数，更详细的内容请参考原项目地址。

加载当前目录下的名为“test.jpg”的图片，得到ndarray类型的数据image

```
image = face_recognition.load_image_file('test.jpg')
```

对image进行分析，得到照片中脸的位置信息face_locations，能同时获取多张脸的位置，所以返回类型为list

```
face_locations = face_recognition.face_locations(image)
```

输入image，face_locations，得到脸的特征值face_encodings，能同时获取多张脸的特征值，所以返回类型为list

```
face_encodings = face_recognition.face_encodings(image, face_locations)
```

比较两个特征值——encoding1与encoding2，匹配返回True，否则返回False。tolerance越低，顾名思义，容错率越低

```
matches = face_recognition.compare_faces(encoding1, encoding2, tolerance=0.38)
```

接下来运行一个实例，以下实例改编自项目原址一个用picamera库实现的demo，这里使用opencv实现：

```python
# coding = utf-8

import face_recognition
import cv2

创建视频对象

video_capture = cv2.VideoCapture(0)

加载当前目录下名为'test.jpg'的照片，照片里需要有且仅有一张脸，这张脸将作为认识的脸

print('loading...')
image = face_recognition.load_image_file('test.jpg')
face_encoding = face_recognition.face_encodings(image)[0]

while True:

print('Capturing image.')

# 读取一帧照片

ret, frame = video_capture.read()

# 把照片缩小一点，能加快处理速度

frame = cv2.resize(frame, (0, 0), fx=0.25, fy=0.25)

# 将cv2用的BGR颜色转换为face_recognition用的RBG颜色

rgb_frame = frame[:, :, ::-1]

# 获取这一帧图片里所有人脸的位置和特征值

face_locations = face_recognition.face_locations(rgb_frame)
print('Found {} faces in image.'.format(len(face_locations)))
face_encodings = face_recognition.face_encodings(output, face_locations)

# 对获取的每张脸进行循环，判断是否是认识的脸

for face_encoding in face_encodings:

    # 判断当前的脸是否与认识的脸匹配

    match = face_recognition.compare_faces([face_encoding], face_encoding)
    name = '<Unknown Person>'

    if match[0]:
        name = 'test'  # test为'test.jpg'里面人脸的名字
    print('I see someone named {}!'.format(name))
```

运行实例时，你需要在运行的当前目录下放置名为“test.jpg”的包含一张人脸的图片，可以使用你的摄像头临时拍一张，但对不同类型的设备而言，指令不同。

Picamera，直接在命令行输入：

```python
raspistill -o test.jpg
```

Webcam，需要先安装fswebcam，在命令行输入：

```
sudo apt-get install fswebcam
```

安装完成后，使用下面命令拍照：

```
fswebcam test.jpg
```

运行完实例后，结合前面几个函数的介绍，以及实例里的注释分析，相信你对如何使用face_recognition库，有了基本的认识，项目原址有更多的例子等待着你去探索。

2.安装并使用picamera库
以上的实例是通过opencv实现的，如果你因为时间原因不想安装opencv，依然建议你看一下这篇Adrian Rosebrock文章：

https://www.pyimagesearch.com/2017/09/04/raspbian-stretch-install-opencv-3-python-on-your-raspberry-pi/

至少要从里面挑出安装pip，virtualenv，搭建虚拟环境以及在虚拟环境里安装numpy的部分，因为使用picamera库也需要这些东西。

安装picamera库，在命令行输入：

```
sudo apt-get update
sudo apt-get upgrade
sudo apt-get install python3-picamera
```

用picamera库实现的实例：

coding = utf-8

```
import face_recognition
import picamera
import numpy as np
```

创建视频对象

```
camera = picamera.PiCamera()
```

设置分辨率

```
camera.resolution = (320, 240)
```

初始化一个空的ndarray类型的数据

```
rgb_frame = np.empty((240, 320, 3), dtype=np.uint8)
```

加载当前目录下名为'test.jpg'的照片，照片里需要有且仅有一张脸，这张脸将作为认识的脸

```
print('loading...')
image = face_recognition.load_image_file('test.jpg')
face_encoding = face_recognition.face_encodings(image)[0]

while True:



print('Capturing image.')

# 用Picamera读取一帧照片

camera.capture(rgb_frame, format='rgb')

# 获取这一帧图片里所有人脸的位置和特征值

face_locations = face_recognition.face_locations(rgb_frame)
print('Found {} faces in image.'.format(len(face_locations)))
face_encodings = face_recognition.face_encodings(rgb_frame, face_locations)

# 对获取的每张脸进行循环，判断是否是认识的脸

for face_encoding in face_encodings:

    # 判断当前的脸是否与认识的脸匹配

    match = face_recognition.compare_faces([face_encoding], face_encoding)
    name = '<Unknown Person>'

    if match[0]:
        name = 'test'  # test为'test.jpg'里面人脸的名字
    print('I see someone named {}!'.format(name))
```

总结
以上内容教给你如何搭建环境，并帮你的简单分析了face_recognition库的使用方法，具体如何使用还需要靠你自己去创造。

不过，需要注意：

1.如果你使用树莓派摄像头模块（Picamera），那么picamera库的方案最适合你，如果想使用opencv的方案，需要做一些配置。方法如下，首先在命令行输入下面的命令，新建或编辑这个文件：

```
sudo nano /etc/modules
```

在里面写入以下内容：

```
bcm2835-v4l2
```

2.如果你使用USB摄像头，那么你只能使用opencv的方案。

代码
https://github.com/LoveThinkinghard/Raspibot

# 树莓派4B基于Opencv（人）猫脸追踪云台

> 前言：本文实现了基于树莓派4B的猫脸追踪装置，可以利用摄像头实时检测猫脸，并驱动舵机锁定追踪猫脸，使猫脸始终位于图像中心

> 硬件：树莓派4B，两个SG-90舵机组成的云台，500万像素CSI接口摄像头
> 算法： Opencv库，GPIO库，PID控制

> 视觉追踪思路：
> 1，利用Opencv库实现摄像头图像的采集与处理
> 2，利用Opencv中提供的级联分类器，载入训练好的Haar特征分类器，实现猫脸的识别
> 3，绘制猫脸的矩形区域，并将该区域中心与图片中心（像素点中心）做对比，作为控制误差来源
> 4， 使用PID算法根据误差计算舵机占空比，进而控制舵机转动角度，实现摄像头的移动

# 1. 目标检测原理

## 基于Haar特征的级联分类器

这是由Paul Viola 和 Michael Jones 2001 年在论文《Rapid Object Detection using a Boosted Cascade of Simple Features》中提出的一种高效目标检测方法。
这种机器学习方法基于大量正面、负面图像训练级联函数，然后用于检测其他图像中的对象。

这里，我们将用它进行猫脸识别。最初，该算法需要大量正类图像（猫脸图像）和负类图像（不带猫脸的图像）来训练分类器。然后我们需要从中提取特征。

OpenCV 具备训练器和检测器，也可以训练自己的对象分类器，如汽车、飞机等
参考：

1. [http://www.elecfans.com/d/643378.html](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.elecfans.com%2Fd%2F643378.html)
2. [https://gitee.com/BA_Figure/faceai/blob/master/doc/detectionOpenCV.md?_from=gitee_search](https://links.jianshu.com/go?to=https%3A%2F%2Fgitee.com%2FBA_Figure%2Ffaceai%2Fblob%2Fmaster%2Fdoc%2FdetectionOpenCV.md%3F_from%3Dgitee_search)

# 2. 目标检测流程

> 利用Opencv的Python接口实现猫脸检测流程如下：
> 树莓派Opencv库安装参考（无需编译）：https://www.jianshu.com/p/8fc2424d5d6c

1. 读取图片
2. 将图片转换为灰度格式，便于猫脸检测
3. 利用训练好的Haar特征检测图片中的猫脸
4. 绘制猫脸的矩形区域
5. 显示猫脸检测后的图片

参考：
[https://blog.csdn.net/bf02jgtrs00xktcx/article/details/84076390](https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fbf02jgtrs00xktcx%2Farticle%2Fdetails%2F84076390)

# 3. 舵机控制

> 舵机的控制基于PWM波，手头上的舵机控制周期为20ms（50Hz)，发送不同占空比的脉冲能够使舵机转动一定的角度。测试过后我手上的舵机转动0°-180°对应占空比为2.5%-13%（该数据需要自己测试下，见参考资料）

> 实现伺服的原理就是根据检测到的猫脸矩形框中心与图片像素中心的X，Y差值，计算得到对应的舵机占空比的变化

![img](Pic_Source/22670226-1ffaedb423b9fcc4.png)

图片.png

参考：
[https://shumeipai.nxez.com/2018/06/21/pan-tilt-multi-servo-control.html](https://links.jianshu.com/go?to=https%3A%2F%2Fshumeipai.nxez.com%2F2018%2F06%2F21%2Fpan-tilt-multi-servo-control.html)

# 系统概览

![img](Pic_Source/22670226-a52af1a19ce7fea0.jpg)

成品图.jpg

特别注意： 我这里摄像头是正放的，排线朝下。实际上排线朝上比较合适点，那样的话需要将读取的图像旋转180°后进行处理，具体请参考:[http://www.waveshare.net/study/article-903-1.html](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.waveshare.net%2Fstudy%2Farticle-903-1.html)
或Opencv函数：cv2.rotate(),具体请参考Opencv文档

我这里是先摄像头读取，然后一帧一帧处理，见后面代码

# 代码实现

## 1. 载入分类器

> OpenCV中提供有级联分类器类CascadeClassifier
> 首先，创建一个分类器对象face_cascade，
> 将训练好的猫脸分类器“haarcascade_frontalcatface.xml”载入到face_cascade对象中

```python
import cv2 as cv

cap = cv.VideoCapture(0)
#实际后面是一帧一帧图像处理，可能这就是延时的原因吧:(
cap.set(3, 320)
cap.set(4, 240)
#设置图片大小320x240，处理速度快， 图片中心也就是x=160,y=120
face_cascade = cv.CascadeClassifier(
    '/home/pi/Code/haarcascades/haarcascade_frontalcatface.xml')
#该处分类器下载地址：https://github.com/opencv/opencv/tree/master/data/haarcascades
#下载后放在树莓派中，地址按自己修改的填
```

## 2. 图像预处理与分类器检测

> 逐帧读取图像处理成灰度图像，加快检测速度；灰度图像保存在frame_gray中
> 调用CascadeClassifier类的detectMultiScale方法，输入待检测灰度像等相关参数，实现输入图像的检测，返回被检测物体的矩形框向量组faces
> detectMultiScale是多尺度多目标检测
> 受制于本人水平，图像预处理没啥骚操作：）

```python
ret, frame = cap.read()
    gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)
    faces = face_cascade.detectMultiScale(gray)
```

参考：
1.[https://www.cnblogs.com/lyx2018/p/7073025.html](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Flyx2018%2Fp%2F7073025.html)
2.[http://www.85kf.com/news/4739.html](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.85kf.com%2Fnews%2F4739.html)

## 3. 绘制矩形区域，得到矩形区域位置信息

```python
if len(faces) > 0:
        #(x,y)代表了矩形框的左上角像素值，(w,h)就是矩形框的长度和高，
        #由此可知矩形框中心像素位置，与图片中心做对比产生控制误差
        for (x, y, w, h) in faces:
            cv.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 0), 2)
            result_x[0] = x
            result_x[1] = w
            result_y[0] = y
            result_y[1] = h
```

## 4. GPIO初始化

```python
pan_pin = 33
tilt_pin = 31
GPIO.setmode(GPIO.BOARD)
# 注意BOARD和BCM模式是不一样的，别搞错了，两个舵机信号线也别接反了。。
GPIO.setup(pan_pin, GPIO.OUT)
GPIO.setup(tilt_pin, GPIO.OUT)
GPIO.setwarnings(False)
pan = GPIO.PWM(pan_pin, 50)  # 50HZ
tilt = GPIO.PWM(tilt_pin, 50)
#PWM频率是50HZ，对应控制周期20ms，与舵机匹配
#启动时舵机占空比7.75%即90°位置
pan.start(7.75)
tilt.start(7.75)
time.sleep(1)
```

## 5. PID控制

> 为了后面方便开多进程，和使代码简化，创建个PID计算函数，这里只使用了PD比例微分控制，使用列表作为参数，便于在函数中更新参数值

```python
def set_pwm(list1, list2):
    err = list1[0] + list1[1] / 2 - list2[2]
    pwm = err * 0.0012 + 0.0001 * (err - list2[0])
    list2[0] = err
    list2[1] += pwm
    if list2[1] > 13:
        list2[1] = 12
    if list2[1] < 2.5:
        list2[1] = 3
```

## 6. 多线程计算及舵机控制

```bash
lastError_x = 0
lastError_y = 0

w_center = 160
h_center = 120

result_x = [160, 0]
result_y = [120, 0]
para_x = [lastError_x, X_Duty, w_center]
para_y = [lastError_y, Y_Duty, h_center]
#以上是参数列表，方便向函数中传入参数并修改
```

```php
  threads = []
        t1 = threading.Thread(target=set_pwm, args=(result_x, para_x))
        threads.append(t1)
        t2 = threading.Thread(target=set_pwm, args=(result_y, para_y))
        threads.append(t2)

        for t in threads:
            t.setDaemon(True)
            t.start()
            print('start')
        t.join()
        #这里不知道写的对不对：(

        print('X_Duty-> ' + str(para_x[1]))
        print('Y_Duty-> ' + str(para_y[1]))
        tilt.ChangeDutyCycle(para_y[1])
        pan.ChangeDutyCycle(15.5 - para_x[1])
        #15.5是根据舵机个性化修改的，目的是与PWM数据匹配，因为俯仰舵机和旋转舵机在减小误差上控制占空比增减是相反的
        #按理说PID函数中，X_Duty  -= PWM，为了PID函数的通用性，我都用了Duty += PWM，在方法ChangeDutyCycle（）中做了匹配修改

        #sleep必不可少，不然反应不过来，舵机不动
        time.sleep(0.3)

    pan.ChangeDutyCycle(0)
    tilt.ChangeDutyCycle(0)
    #将占空比置为0，使得舵机定位后不再动
    cv.imshow("capture", frame)
```

# 完整代码

```python
import cv2 as cv
import RPi.GPIO as GPIO
import time
import signal
import threading

pan_pin = 33
tilt_pin = 31

lastError_x = 0
lastError_y = 0

# duty: 2.5-13
X_Duty = 7.75
Y_Duty = 7.75

w_center = 160
h_center = 120

result_x = [160, 0]
result_y = [120, 0]
para_x = [lastError_x, X_Duty, w_center]
para_y = [lastError_y, Y_Duty, h_center]

pan_pin = 33
tilt_pin = 31
GPIO.setmode(GPIO.BOARD)
GPIO.setup(pan_pin, GPIO.OUT)
GPIO.setup(tilt_pin, GPIO.OUT)
GPIO.setwarnings(False)
pan = GPIO.PWM(pan_pin, 50)  # 50HZ
tilt = GPIO.PWM(tilt_pin, 50)
pan.start(7.75)
tilt.start(7.75)
time.sleep(1)


def set_pwm(list1, list2):
    err = list1[0] + list1[1] / 2 - list2[2]
    pwm = err * 0.0012 + 0.0001 * (err - list2[0])
    list2[0] = err
    list2[1] += pwm
    if list2[1] > 13:
        list2[1] = 12
    if list2[1] < 2.5:
        list2[1] = 3


cap = cv.VideoCapture(0)
cap.set(3, 320)
cap.set(4, 240)

face_cascade = cv.CascadeClassifier(
    '/home/pi/Code/haarcascades/haarcascade_frontalcatface.xml')

while True:

    ret, frame = cap.read()
    gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)
    faces = face_cascade.detectMultiScale(gray)

    if len(faces) > 0:
        for (x, y, w, h) in faces:
            cv.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 0), 2)
            result_x[0] = x
            result_x[1] = w
            result_y[0] = y
            result_y[1] = h

        threads = []
        t1 = threading.Thread(target=set_pwm, args=(result_x, para_x))
        threads.append(t1)
        t2 = threading.Thread(target=set_pwm, args=(result_y, para_y))
        threads.append(t2)

        for t in threads:
            t.setDaemon(True)
            t.start()
            print('start')
        t.join()

        print('X_Duty-> ' + str(para_x[1]))
        print('Y_Duty-> ' + str(para_y[1]))
        pan.ChangeDutyCycle(15.5 - para_x[1])
        tilt.ChangeDutyCycle(para_y[1])
        time.sleep(0.3)

    pan.ChangeDutyCycle(0)
    tilt.ChangeDutyCycle(0)
    cv.imshow("capture", frame)

    if cv.waitKey(1) > 0:
        break

cap.release()
GPIO.cleanup()
cv.destroyAllWindows()
```

# 不足

- 在淘宝25.5买的舵机云台不靠谱，旋转舵机一卡一卡的，日
- 延迟将近1s吧，可能是因为计算代价高？可能是逐帧处理太慢？后续有机会，姿势水平提高了，会继续优化
- 欢迎大神指出问题， 本文仅做参考，作为课程作业的一个记录，也是第一次接触Opencv视觉伺服，挺好玩的。PS.光看Opencv文档就觉得头大哈哈哈:(

# 其他参考资料

1. [https://www.freesion.com/article/564916506/](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.freesion.com%2Farticle%2F564916506%2F)
2. [https://gitee.com/BA_Figure/faceai/blob/master/doc/detectionOpenCV.md?_from=gitee_search](https://links.jianshu.com/go?to=https%3A%2F%2Fgitee.com%2FBA_Figure%2Ffaceai%2Fblob%2Fmaster%2Fdoc%2FdetectionOpenCV.md%3F_from%3Dgitee_search)

3.[http://www.360doc.com/content/19/0516/09/63281354_836028944.shtml](https://links.jianshu.com/go?to=http%3A%2F%2Fwww.360doc.com%2Fcontent%2F19%2F0516%2F09%2F63281354_836028944.shtml)

1. [https://www.pythonf.cn/read/98144](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.pythonf.cn%2Fread%2F98144)
2. [https://www.cnblogs.com/xiaowuyi/p/4319699.html](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Fxiaowuyi%2Fp%2F4319699.html)

6.https://www.jianshu.com/p/8fc2424d5d6c

# 树莓派智能家居-天气预报和实时温湿度监控

获取天气预报

    目前有现成的天气预报API，直接调用即可，代码如下：

```python
def getWeather(city,date=0):
    s=''
    rb=requests.get('http://wthrcdn.etouch.cn/weather_mini?city='+city)
    #print(rb.text)
    data=json.loads(rb.text)
    if(data['status']==1000):
        d=data['data']
        if(date==0):
            s+=d['city']+'今天'+d['forecast'][0]['type']+','
            s+=d['forecast'][0]['low'][2:]+'到'+d['forecast'][0]['high'][2:]+','
            s+=d['forecast'][0]['fengxiang']+d['forecast'][0]['fengli'][8:]+','
            s+='当前室外温度:'+d['wendu']+'度,'
            s+=d['ganmao']
        elif(date>0 and date<5):
            s+=d['city']
            if(date==1):
                s+='明天'
            elif(date==2):
                s+='后天'
            else:
                s+=d['forecast'][date]['date']
            s+=d['forecast'][date]['type']+','
            s+=d['forecast'][date]['low'][2:]+'到'+d['forecast'][date]['high'][2:]+','
            s+=d['forecast'][date]['fengxiang']+d['forecast'][date]['fengli'][8:]
        elif(date==-1):
            s+=d['city']+'昨天'+d['yesterday']['type']+','
            s+=d['yesterday']['low'][2:]+'到'+d['yesterday']['high'][2:]+','
            s+=d['yesterday']['fx']+d['yesterday']['fl'][8:]
    else:
        s='天气请求失败'
    return s
```

  输入参数：city-要获取的天气的城市名字，date-获取什么时候的天气，0表示今天。但是我们要做的是从用户说的话中获得他想知道什么城市，哪天的天气。这首先需要知道有什么城市，然后通过关键词判断用户的意图。总的代码如下：

```python
#weather.py
import requests
import json
import re

class Weather:
    cityList=[]
```

```python
def __init__(self):
    self.getCity()

def getCity(self):
    fileName='city.txt'
    with open(fileName,'r') as f:
        lines=f.readlines()
        for line in lines:
            cities=line.split(' ')
            for w in cities:
                self.cityList.append(w.strip())
                self.cityList.append(w.strip().replace('市',''))

def isCityExits(self,text):
    isExist=False
    cityName=''
    #print(self.cityList)
    for c in self.cityList:
        if(c in text):
            cityName=c
            isExist=True
            break
    return isExist,cityName

def getWeatherByText(self,text):
    result=''
    #judge city in text
    isCity,cityName=self.isCityExits(text)
    #print(isCity)
    if(isCity):
        #is get weather
        reStr=r'(.*?)'+cityName+r'(.*?)今天(.*?)天气(.*?)'
        obj=re.search(reStr,text,re.M|re.I)
        if(obj!=None):
            result=self.getWeather(cityName,0)
            return result
        reStr=r'(.*?)今天(.*?)'+cityName+r'(.*?)天气(.*?)'
        obj=re.search(reStr,text,re.M|re.I)
        if(obj!=None):
            result=self.getWeather(cityName,0)
            return result

        reStr=r'(.*?)'+cityName+r'(.*?)明天(.*?)天气(.*?)'
        obj=re.search(reStr,text,re.M|re.I)
        if(obj!=None):
            result=self.getWeather(cityName,1)
            return result
        reStr=r'(.*?)明天(.*?)'+cityName+r'(.*?)天气(.*?)'
        obj=re.search(reStr,text,re.M|re.I)
        if(obj!=None):
            result=self.getWeather(cityName,1)
            return result

        reStr=r'(.*?)'+cityName+r'(.*?)后天(.*?)天气(.*?)'
        obj=re.search(reStr,text,re.M|re.I)
        if(obj!=None):
            result=self.getWeather(cityName,2)
            return result
        reStr=r'(.*?)后天(.*?)'+cityName+r'(.*?)天气(.*?)'
        obj=re.search(reStr,text,re.M|re.I)
        if(obj!=None):
            result=self.getWeather(cityName,2)
            return result

        reStr=r'(.*?)'+cityName+r'(.*?)昨天(.*?)天气(.*?)'
        obj=re.search(reStr,text,re.M|re.I)
        if(obj!=None):
            result=self.getWeather(cityName,-1)
            return result
        reStr=r'(.*?)昨天(.*?)'+cityName+r'(.*?)天气(.*?)'
        obj=re.search(reStr,text,re.M|re.I)
        if(obj!=None):
            result=self.getWeather(cityName,-1)
            return result

        reStr=r'(.*?)'+cityName+r'(.*?)天气(.*?)'
        obj=re.search(reStr,text,re.M|re.I)
        if(obj!=None):
            result=self.getWeather(cityName,0)
            return result

    return result
```

```python
​            
​    def getWeather(self,city,date=0):
​        s=''
​        rb=requests.get('http://wthrcdn.etouch.cn/weather_mini?city='+city)
​        #print(rb.text)
​        data=json.loads(rb.text)
​        if(data['status']==1000):
​            d=data['data']
​            if(date==0):
​                s+=d['city']+'今天'+d['forecast'][0]['type']+','
​                s+=d['forecast'][0]['low'][2:]+'到'+d['forecast'][0]['high'][2:]+','
​                s+=d['forecast'][0]['fengxiang']+d['forecast'][0]['fengli'][8:]+','
​                s+='当前室外温度:'+d['wendu']+'度,'
​                s+=d['ganmao']
​            elif(date>0 and date<5):
​                s+=d['city']
​                if(date==1):
​                    s+='明天'
​                elif(date==2):
​                    s+='后天'
​                else:
​                    s+=d['forecast'][date]['date']
​                s+=d['forecast'][date]['type']+','
​                s+=d['forecast'][date]['low'][2:]+'到'+d['forecast'][date]['high'][2:]+','
​                s+=d['forecast'][date]['fengxiang']+d['forecast'][date]['fengli'][8:]
​            elif(date==-1):
​                s+=d['city']+'昨天'+d['yesterday']['type']+','
​                s+=d['yesterday']['low'][2:]+'到'+d['yesterday']['high'][2:]+','
​                s+=d['yesterday']['fx']+d['yesterday']['fl'][8:]
​        
​        else:
​            s='天气请求失败'
​        return s
```

```python
#w=Weather()
#print(w.getWeatherByText('上海今天天气怎么样'))
```

其中city.txt的内容在附录。上面通过类的形式封装了天气相关操作。使用时，调用getweatherByText()函数。该函数首先判断输入文本中有没有城市名称，若存在城市名称，在通过正则表达式判断是否相应的关键词，若存在，则获取对应城市，对应日期的天气。

实时监控温湿度

    dht11是一款便宜、又好用用于获取空气温湿度的传感器。 其精度湿度±5%RH， 温度±2℃，量程湿度20-90%RH， 温度0~50℃。DHT11利用单总线协议，因此有严格的时序，关系通信协议可参考<DHT11使用笔记>。
    
    树莓派根据通信协议直接获取DHT11数据的代码如下：

```
#encoding=utf-8
import RPi.GPIO as GPIO
import time
import dht11
import datetime
import re
def getDHT11Data_1(dht11_pin):
    isOk=True
    GPIO.setmode(GPIO.BOARD)#io number with BOARD
    GPIO.setup(dht11_pin, GPIO.OUT)
    GPIO.output(dht11_pin, GPIO.LOW)
    time.sleep(0.02)                      #给信号提示传感器开始工作
    GPIO.output(dht11_pin, GPIO.HIGH)
    GPIO.setup(dht11_pin, GPIO.IN)
    while GPIO.input(dht11_pin) == GPIO.LOW:
        continue
    while GPIO.input(dht11_pin) == GPIO.HIGH:
        continue
    data=[]
    j=0
    while j < 40:
        k = 0
        while GPIO.input(dht11_pin) == GPIO.LOW:
            continue
        while GPIO.input(dht11_pin) == GPIO.HIGH:
            k += 1
            if k > 100:
                break
        if k < 8:
            data.append(0)
        else:
            data.append(1)
        j += 1
    humidity_bit = data[0:8]        #分组
    humidity_point_bit = data[8:16]
    temperature_bit = data[16:24]
    temperature_point_bit = data[24:32]
    check_bit = data[32:40]
```

```
​    
​    humidity = 0
​    humidity_point = 0
​    temperature = 0
​    temperature_point = 0
​    check = 0
​     
​    for i in range(8):
​        humidity += humidity_bit[i] * 2 ** (7 - i)              #转换成十进制数据
​        humidity_point += humidity_point_bit[i] * 2 ** (7 - i)
​        temperature += temperature_bit[i] * 2 ** (7 - i)
​        temperature_point += temperature_point_bit[i] * 2 ** (7 - i)
​        check += check_bit[i] * 2 ** (7 - i)
​     
    tmp = humidity + humidity_point + temperature + temperature_point #十进制的数据相加
```

    if check == tmp:#数据校验，相等则输出
        print ("temperature : ", temperature, ".", temperature_point, ", humidity : " , humidity, ".", humidity_point)
    else:
        #错误输出错误信息，和校验数据
        isOk=False
        print ("DHT11 Get Wrong")
        print ("temperature : ", temperature, ", humidity : " , humidity, " check : ", check, " tmp : ", tmp)
    GPIO.cleanup()
    
    return isOk,temperature,temperature_point,humidity,humidity_point

 树莓派上面跑着一个linux系统，由于进程调用的缘故并不严格服从DHT11通信的时序，因此这样直接写代码获取数据很容易出错。szazo的github项目解决了这个问题，使用他的代码可以准确的得到DHT11的数据。此外同上面获取天气的情况一样，需要通过关键词判断用户的意图，总的代码如下：

```
#getDHT11.py
#encoding=utf-8
import RPi.GPIO as GPIO
import time
import dht11
import datetime
import re

class GetDHT11:
    isOk=True
    def __init__(self,dht11_pin):
        GPIO.setwarnings(True)
        GPIO.setmode(GPIO.BOARD)
        self.instance = dht11.DHT11(pin=dht11_pin)
```

```
​    
​    def __del__(self):
​        GPIO.cleanup()
​        
​    def getDataDHT11(self):
​        result = self.instance.read()
​        if result.is_valid():
​            self.isOk=True
​            return result.temperature,result.humidity
​        else:
​            self.isOk=False
​            return 0,0
​            
    def getIsOk(self):
        return self.isOk
```

    def getTemperatureAndHumidityByText(self,text):
        reStr=r'(.*?)现在(.*?)温度(.*?)'
        obj=re.search(reStr,text,re.M|re.I)
        if(obj!=None):
            t,h=do.getDataDHT11()
            if(do.getIsOk()):
                result='当前温度'+str(int(t))+'摄氏度,空气湿度百分之'+str(h)
                return result
    
        reStr=r'(.*?)现在(.*?)湿度(.*?)'
        obj=re.search(reStr,text,re.M|re.I)
        if(obj!=None):
            t,h=do.getDataDHT11()
            if(do.getIsOk()):
                result='当前温度'+str(int(t))+'摄氏度,空气湿度百分之'+str(h)
                return result
    
        eStr=r'(.*?)当前(.*?)温度(.*?)'
        obj=re.search(reStr,text,re.M|re.I)
        if(obj!=None):
            t,h=do.getDataDHT11()
            if(do.getIsOk()):
                result='当前温度'+str(int(t))+'摄氏度,空气湿度百分之'+str(h)
                return result
    
        reStr=r'(.*?)当前(.*?)湿度(.*?)'
        obj=re.search(reStr,text,re.M|re.I)
        if(obj!=None):
            t,h=do.getDataDHT11()
            if(do.getIsOk()):
                result='当前温度'+str(int(t))+'摄氏度,空气湿度百分之'+str(h)
                return result
    
        reStr=r'(.*?)此(.*?)温度(.*?)'
        obj=re.search(reStr,text,re.M|re.I)
        if(obj!=None):
            t,h=do.getDataDHT11()
            if(do.getIsOk()):
                result='当前温度'+str(int(t))+'摄氏度,空气湿度百分之'+str(h)
                return result
    
        reStr=r'(.*?)此(.*?)湿度(.*?)'
        obj=re.search(reStr,text,re.M|re.I)
        if(obj!=None):
            t,h=do.getDataDHT11()
            if(do.getIsOk()):
                result='当前温度'+str(int(t))+'摄氏度,空气湿度百分之'+str(h)
                return result
        return ''

主程序

    在上一篇博文写的基础上，代码修改如下：

```
from weather import Weather
from speech import *
from voice import *
from chatbot import *
from getDHT11 import GetDHT11
from microrecord import *
import time

mp3FileName='dialog.mp3'
wavFileName='dialog.wav'

dht11_pin=12

do=GetDHT11(dht11_pin)
wobj=Weather()

def getResponse(text):
    output_text=''
    #get weather
    output_text=wobj.getWeatherByText(text)
    if(len(output_text)>0):
        t,h=do.getDataDHT11()
        if(do.getIsOk()):
            output_text+='当前温度'+str(int(t))+'摄氏度,空气湿度百分之'+str(h)
    else:
        output_text=do.getTemperatureAndHumidityByText(text)
        if(len(output_text)==0):
            output_text=chat(text)
    return output_text

while True:
    getMicroRecord(wavFileName)
    input_text=speechRecognition(wavFileName)
    print('input:'+input_text)
    if(len(input_text)==0):
        break
    output_text=getResponse(input_text)

    if(speechSynthesis(output_text,mp3FileName)):
        playMp3ByShell(mp3FileName)
    print('output:'+output_text)

print('dialog done')
```

效果还是可以的。

附录：city.txt

```
河南省
郑州市 洛阳市 焦作市 商丘市 信阳市 周口市 鹤壁市 安阳市 濮阳市 驻马店市
南阳市 开封市 漯河市 许昌市 新乡市 济源市 灵宝市 偃师市 邓州市 登封市 三门峡市
新郑市 禹州市 巩义市 永城市 长葛市 义马市 林州市 项城市 汝州市 荥阳市
平顶山市 卫辉市 辉县市 舞钢市 新密市 孟州市 沁阳市 郏县
安徽省
合肥市 亳州市 芜湖市 马鞍山市 池州市 黄山市 滁州市 安庆市
淮南市 淮北市 蚌埠市 宿州市 宣城市 六安市 阜阳市
铜陵市 明光市 天长市 宁国市 界首市 桐城市 潜山市
福建省
福州市 厦门市 泉州市 漳州市 南平市 三明市 龙岩市 莆田市
宁德市 建瓯市 武夷山市 长乐市 福清市 晋江市 南安市 福安市
龙海市 邵武市 石狮市 福鼎市 建阳市 漳平市 永安市
甘肃省
兰州市 白银市 武威市 金昌市 平凉市 张掖市 嘉峪关市 酒泉市
庆阳市 定西市 陇南市 天水市 玉门市 临夏市 合作市 敦煌市 甘南州
贵州省
贵阳市 安顺市 遵义市 六盘水市 兴义市 都匀市 凯里市 毕节市 清镇市
铜仁市 赤水市 仁怀市 福泉市
海南省
海口市 三亚市 万宁市 文昌市 儋州市 琼海市 东方市 五指山市
河北省
石家庄市 保定市 唐山市 邯郸市邢台市 沧州市 衡水市 廊坊市 承德市 迁安市
鹿泉市 秦皇岛市 南宫市 任丘市 叶城市 辛集市 涿州市 定州市 晋州市 霸州市
黄骅市 遵化市 张家口市 沙河市 三河市 冀州市 武安市 河间市深州市 新乐市
泊头市 安国市 双滦区 高碑店市
黑龙江省
哈尔滨市 伊春市 牡丹江市 大庆市 鸡西市 鹤岗市 绥化市 齐齐哈尔市
黑河市 富锦市 虎林市 密山市 佳木斯市 双鸭山市 海林市 铁力市 北安市
五大连池市 阿城市 尚志市 五常市 安达市 七台河市 绥芬河市 双城市
海伦市 宁安市 讷河市 穆棱市 同江市 肇东市
湖北省
武汉市 荆门市 咸宁市 襄阳市 荆州市 黄石市 宜昌市 随州市
鄂州市 孝感市 黄冈市 十堰市 枣阳市 老河口市 恩施市 仙桃市
天门市 钟祥市 潜江市 麻城市 洪湖市 汉川市 赤壁市 松滋市
丹江口市 武穴市 广水市 石首市大冶市 枝江市 应城市 宜城市
当阳市 安陆市 宜都市 利川市
湖南省
长沙市 郴州市 益阳市 娄底市 株洲市 衡阳市 湘潭市
岳阳市 常德市 邵阳市 永州市 张家界市 怀化市 浏阳市
醴陵市 湘乡市 耒阳市 沅江市 涟源市 常宁市 吉首市
津市市 冷水江市 临湘市 汨罗市 武冈市 韶山市 湘西州
吉林省
长春市 吉林市 通化市 白城市 四平市 辽源市 松原市 白山市
集安市 梅河口市 双辽市 延吉市 九台市 桦甸市 榆树市 蛟河市
磐石市 大安市 德惠市 洮南市 龙井市 珲春市 公主岭市 图们市
舒兰市 和龙市 临江市 敦化市
江苏省
南京市 无锡市 常州市 扬州市 徐州市 苏州市 连云港市 盐城市
淮安市 宿迁市 镇江市 南通市 泰州市 兴化市 东台市 常熟市
江阴市 张家港市 通州市 宜兴市 邳州市 海门市 溧阳市 泰兴市
如皋市 昆山市 启东市 江都市 丹阳市 吴江市 靖江市 扬中市
新沂市 仪征市 太仓市 姜堰市 高邮市 金坛市 句容市 灌南县
江西省
南昌市 赣州市 上饶市 宜春市 景德镇市 新余市 九江市 萍乡市
抚州市 鹰潭市 吉安市 丰城市 樟树市 德兴市 瑞金市 井冈山市
高安市 乐平市 南康市 贵溪市 瑞昌市 东乡县 广丰县 信州区 三清山
辽宁省
沈阳市 葫芦岛市 大连市 盘锦市 鞍山市 铁岭市 本溪市 丹东市
抚顺市 锦州市 辽阳市 阜新市 调兵山市 朝阳市 海城市 北票市
盖州市 凤城市 庄河市 凌源市 开原市 兴城市 新民市 大石桥市
东港市 北宁市 瓦房店市 普兰店市 凌海市 灯塔市 营口市
青海省
西宁市 格尔木市 德令哈市
山东省
济南市 青岛市 威海市 潍坊市 菏泽市 济宁市 东营市烟台市
淄博市 枣庄市 泰安市 临沂市 日照市 德州市 聊城市 滨州市
乐陵市 兖州市 诸城市 邹城市 滕州市 肥城市 新泰市 胶州市
胶南市 即墨市 龙口市 平度市 莱西市
山西省
太原市 大同市 阳泉市 长治市 临汾市 晋中市 运城市 忻州市
朔州市 吕梁市 古交市 高平市 永济市 孝义市 侯马市 霍州市
介休市 河津市 汾阳市 原平市 晋城市 潞城市
陕西省
西安市 咸阳市 榆林市 宝鸡市 铜川市 渭南市 汉中市 安康市
商洛市 延安市 韩城市 兴平市 华阴市
四川省
成都市 广安市 德阳市 乐山市 巴中市 内江市 宜宾市 南充市
都江堰市 自贡市 泸州市 广元市达州市 资阳市 绵阳市 眉山市
遂宁市 雅安市 阆中市 攀枝花市 广汉市 绵竹市 万源市 华蓥市
江油市 西昌市 彭州市 简阳市 崇州市 什邡市 峨眉山市 邛崃市 双流县
云南省
昆明市 玉溪市 大理市 曲靖市 昭通市 保山市 丽江市 临沧市 楚雄市
开远市 个旧市 景洪市 安宁市 宣威市
浙江省
杭州市 宁波市 绍兴市 温州市 台州市 湖州市 嘉兴市 金华市 舟山市
衢州市 丽水市 余姚市 乐清市 临海市 温岭市 永康市 瑞安市 慈溪市
义乌市 上虞市 诸暨市 海宁市 桐乡市 兰溪市 龙泉市 建德市 富德市
富阳市 平湖市 东阳市 嵊州市 奉化市 临安市 江山市
台湾省
台北市 台南市 台中市 高雄市 桃源市
广东省
广州市 深圳市珠海市 汕头市 佛山市 韶关市 湛江市 肇庆市 江门市 茂名市 惠州市 梅州市 汕尾市 河源市 阳江市 清远市 东莞市 中山市 潮州市 揭阳市 云浮市
自治区编辑
广西壮族自治区
南宁市 贺州市 玉林市 桂林市 柳州市 梧州市 北海市 钦州市 百色市
防城港市 贵港市 河池市 崇左市 来宾市 东兴市 桂平市 北流市
岑溪市 合山市 凭祥市 宜州市
内蒙古自治区
呼和浩特市 呼伦贝尔市 赤峰市 扎兰屯市 鄂尔多斯市 乌兰察布市
巴彦淖尔市 二连浩特市 霍林郭勒市 包头市 乌海市 阿尔山市
乌兰浩特市 锡林浩特市 根河市 满洲里市 额尔古纳市 牙克石市
临河市 丰镇市 通辽市
宁夏回族自治区
银川市 固原市 石嘴山市 青铜峡市 中卫市 吴忠市 灵武市
西藏藏族自治区
拉萨市 那曲市 山南市 林芝市 昌都市 阿里地区日喀则市
新疆维吾尔自治区
乌鲁木齐市 石河子市 喀什市 阿勒泰市 阜康市 库尔勒市 阿克苏市
阿拉尔市 哈密市 克拉玛依市 昌吉市 奎屯市 米泉市 和田市
香港 澳门
北京市 上海市 天津市 重庆市
```

# 树莓派Raspberry命令行配置无线网络连接

前言：
树莓派有多种联网的方式，通过有线网或者通过无线网。通过有线网连接是比较简单的，在开启dhcp的路由器下，直接插上网线就可以联网，本文介绍树莓派无线联网的方式。再没联网的情况下，如果没有屏幕等外设，通过串口连接是一种比较简单有效的方式。

扫描WIFI:
使用如下命令可以扫描附近的无线网：

sudo iwlist wlan0 scan
1
扫描结果如下：

wlan0     Scan completed :
          Cell 01 - Address: F0:B4:29:1F:28:F1
                    ESSID:"00H Studio"
                    Protocol:IEEE 802.11bgn
                    Mode:Master
                    Frequency:2.422 GHz (Channel 3)
                    Encryption key:on
                    Bit Rates:300 Mb/s
                    Extra:rsn_ie=30140100000fac040100000fac040100000fac020000
                    IE: IEEE 802.11i/WPA2 Version 1
                        Group Cipher : CCMP
                        Pairwise Ciphers (1) : CCMP
                        Authentication Suites (1) : PSK
                    Quality=100/100  Signal level=84/100  
          Cell 02 - Address: 06:74:9C:08:3F:7C
                    ESSID:"QLU-2.4G"
                    Protocol:IEEE 802.11bgn
                    Mode:Master
                    Frequency:2.412 GHz (Channel 1)
                    Encryption key:off
                    Bit Rates:144 Mb/s
                    Quality=100/100  Signal level=72/100  
          Cell 03 - Address: D6:50:3F:0B:81:D1
                    ESSID:"7788"
                    Protocol:IEEE 802.11bgn
                    Mode:Master
                    Frequency:2.422 GHz (Channel 3)
                    Encryption key:on
                    Bit Rates:72 Mb/s
                    Extra:rsn_ie=30140100000fac040100000fac040100000fac020c00
                    IE: IEEE 802.11i/WPA2 Version 1
                        Group Cipher : CCMP
                        Pairwise Ciphers (1) : CCMP
                        Authentication Suites (1) : PSK
                    IE: Unknown: DD180050F204104A00011010440001021049000600372A000120
                    Quality=44/100  Signal level=62/100  

这里的“00H Studio”是无线网的名称。IEEE 802.11i/WPA2 Version 1是加密的方式。加密的类型是WPA2类型的。

添加有密码的WIFI网络
通过配置wpa_supplicant.conf可以设置要连接的无线网。

sudo vim /etc/wpa_supplicant/wpa_supplicant.conf
1
在文件末尾出添加一下代码，并替换掉ssid_name以及password即可。

network={
        ssid="ssid_name"
        key_mgmt=WPA-PSK
        psk="password"
}

重启网络
sudo service dhcpcd restart

等待一会儿
ifconfig wlan0

可以查看IP地址是否分配成功

wlan0     Link encap:Ethernet  HWaddr e8:4e:06:34:f8:f5  
          inet addr:192.168.9.177  Bcast:192.168.9.255  Mask:255.255.255.0
          inet6 addr: fdf5:a28:b70c:0:746:52db:d822:14bd/64 Scope:Global
          inet6 addr: fdf5:a28:b70c::6c5/128 Scope:Global
          inet6 addr: fe80::ea4e:6ff:fe34:f8f5/64 Scope:Link
          inet6 addr: fdf5:a28:b70c:0:ea4e:6ff:fe34:f8f5/64 Scope:Global
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:100930 errors:0 dropped:36149 overruns:0 frame:0
          TX packets:290150 errors:0 dropped:2 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:146598855 (139.8 MiB)  TX bytes:3218776758 (2.9 GiB)

连接隐藏网络
如果要连接的是隐藏的网络，需要在配置文件中添加scan_ssid连接。需要添加的内容如下：

network={
    ssid="yourHiddenSSID"
    scan_ssid=1
    psk="Your_wifi_password"
}

添加多个无线网络配置
network={
    ssid="SchoolNetworkSSID"
    psk="passwordSchool"
    id_str="school"
}

network={
    ssid="HomeNetworkSSID"
    psk="passwordHome"
    id_str="home"
}

如果您有两个网络的范围，可以添加优先级选项来在它们之间进行选择。具有最高优先级的范围内的网络将是连接的网络。

network={
    ssid="HomeOneSSID"
    psk="passwordOne"
    priority=1
    id_str="homeOne"
}

network={
    ssid="HomeTwoSSID"
    psk="passwordTwo"
    priority=2
    id_str="homeTwo"
}

添加没有密码的WIFI网络
添加没有密码的WIFI网络需要注意将key_mgmt设置为NONE

network={
ssid=“ssid_name”
key_mgmt=NONE
}

IP的设置
auto wlan0
iface wlan0 inet static
   address 192.168.0.1
   netmask 255.255.255.0
　　wpa-conf /etc/wpa_supplicant/wpa_supplicant.conf

错误的调试
如果出现连接不成功的情况，有很大的可能是由于配置文件配置错误的原因。

sudo wpa_supplicant -c /etc/wpa_supplicant/wpa_supplicant.conf  -i wlan0
1
通过wpa_supplicant的直接连接，如果配置文件出现问题，则会直接提示配置文件的错误详情。

如果出现一下结果，则一般代表配置文件没有问题

Successfully initialized wpa_supplicant
nl80211: Driver does not support authentication/association or connect commands
wlan0: Failed to initialize driver interface

树莓派当中的文件，很多时候希望文件能在局域网内共享，可以通过 Samba 来实现这一目的。

### 安装 Samba

samba 的安装很简单，命令行执行：

```shell
sudo apt-get install samba samba-common-bin
```

### 配置 Samba

配置文件为`/etc/samba/smb.conf`，这里对它进行修改，命令行执行：

```shell
sudo nano /etc/samba/smb.conf
```

注：nano 可以通过 ctrl+y（上一页） 和 ctrl+v（下一页） 实现翻页。

在文件末尾加上如下内容，其中/home/pi/Desktop 为我设置的共享文件夹目录（将其替换为你想共享的目录即可，例如：/home/pi/public）：

```tsx
[public]
   comment = public storage
   path = /home/pi/Desktop
   valid users = pi
   read only = no
   create mask = 0777
   directory mask = 0777
   guest ok = no
   browseable = yes
```

ctrl+o 保存，之后 回车 确认，然后 ctrl+x 退出。

参数说明：

- [public]：共享文件夹名称
- comment：共享文件夹说明
- path：共享文件夹目录
- valid users：有效用户（注释掉，默认是所有人，无密码访问）
- read only：是否只读
- create mask：创建文件的权限
- directory mask：创建文件夹的权限
- guest ok：是否允许访客访问
- browseable：是否可见

其中 valid users 即 pi 为有效用户(访问时的用户名)，还需要添加其到 Samba 中，命令行执行：

```shell
sudo smbpasswd -a pi
```

然后设置访问密码（输入时不会显示）

重启 samba 以生效配置，命令行执行：

```shell
sudo samba restart
```

注：Samba 默认开机自启，无需为重启担心。

### 设置文件权限

在 Samba 配置文件设置权限后，还在系统中将共享文件夹的权限设置为同配置文件中相同的权限，以确保其他用户正常访问及修改文件夹内容，命令行执行：

```shell
sudo chmod -R 777 /home/pi/Desktop
```

### 访问共享文件

Windows：

在资源管理器地址栏输入：`\\192.168.1.4\public`或`\\192.168.1.4`，其中 192.168.1.4 替换为你树莓派的 IP 地址即可。

macOS：

打开 FInder，之后使用快捷键 cmd+k，服务器地址中填写`smb://192.168.1.4/public`，其中 192.168.1.4 替换为你树莓派的 IP 地址，之后点击连接即可。

linux:

```shell
// 先创建一个用于挂载的空文件夹
sudo mkdir /home/pi/Desktop/smb

// 挂载操作
sudo mount -t cifs -o username=用户名,password=密码 //192.168.1.5/public /home/pi/Desktop/smb

// 挂载之后，使用 umount 命令可以卸载
sudo umount /home/pi/Desktop/smb
```

# 树莓派之挂载移动硬盘

[![](https://cdn2.jianshu.io/assets/default_avatar/5-33d2da32c552b8be9a0548c7a4576607.jpg)](https://www.jianshu.com/u/6e7d67a5ea60)

[静夜思_](https://www.jianshu.com/u/6e7d67a5ea60)关注

0.6752017.08.22 18:33:00字数 419阅读 41,658

树莓派用作系统的TF卡容量是16G，对于经常需要下载的我来说还是太小了，为此，我把自己的移动硬盘挂在树莓派上，当作下载盘。  

需要注意的是，树莓派供电太弱，USB口带不动移动硬盘，我专门买了一根外接供电的USB线，来给移动硬盘额外供电。

1.插上硬盘，查看状态

> *sudo fdisk -l*

![](https://upload-images.jianshu.io/upload_images/5042639-e10772d4c42501d6?imageMogr2/auto-orient/strip|imageView2/2/w/640/format/webp)

查看已连接的储存设备，可以看到/dev/sda1▲

2.然后

> *df -h*

![](https://upload-images.jianshu.io/upload_images/5042639-87ed417bcdf40d36?imageMogr2/auto-orient/strip|imageView2/2/w/640/format/webp)

可以看到移动硬盘自动挂载了▲

3.先建一个目录 ，让树莓派挂载在创建的目录

> **sudo mkdir /home/pi/toshiba**

4.然后按照我们的希望挂载

> **sudo mount /dev/sda1  /home/pi/toshiba**

5.*df -h*出现以下▼

![](https://upload-images.jianshu.io/upload_images/5042639-0617128e3f160c31?imageMogr2/auto-orient/strip|imageView2/2/w/573/format/webp)

6.安装NTFS格式可读写软件

> *sudo aptitude install ntfs-3g*

7.加载内核模块

> *modprobe fuse*

8.让移动硬盘开机自动挂载

> *sudo nano /etc/fstab*

最后一行添加

> /dev/sda1  /home/pi/toshiba ntfs-3g defaults,noexec,umask=0000 0 0

9.有时候，挂载会出错，Mount is denied：

![](https://upload-images.jianshu.io/upload_images/5042639-5108c3092018679a.png?imageMogr2/auto-orient/strip|imageView2/2/w/802/format/webp)

mount is denide.

此时，用这个命令

> sudo fuser -m -u /dev/sda1  

然后杀掉

> sudo kill 1308  

就可以按上述步骤重新挂载了

---

**挂载exFAT格式的硬盘**  

FAT 格式U盘 mount 本身就能支持，但如果你的U盘或移动硬盘使用的是 exFAT 格式，mount 会说不支持。没关系，安装 exfat-fuse 软件之后 mount 就支持了。

> sudo apt-get install exfat-fuse

如果想开机自动挂载，而不是每次手工执行，可以编辑 /etc/fstab 文件。比如在末尾添加一行：

> /dev/sda1 /mnt/usbdisk vfat rw,defaults 0 0

# 树莓派修改/etc/fstab导致不能开机解决办法

在进行树莓派挂载硬盘修改过程中修改了/etc/fstab文件，重启后系统不能识别TF卡了，导致不能开机。

需要将/etc/fstab恢复为默认值，方式如下：

1、将有问题的TF卡插入linux系统电脑

由于我有2张树莓派卡，将备用卡插入树莓派开机，再将有问题的TF卡插入树莓派

2、找到fstab文件

挂载的U盘默认在/media/pi目录下，下一层地址为root或rootfs，找到/etc/fstab文件，我这边完整地址如下：

![](https://pic2.zhimg.com/80/v2-3920715bfc0570f2c90b94edced72a71_720w.png)

3、修改文件

采用vi fstab修改文件，恢复为默认值，修改完成输入':wq'保存退出。如果提示不能修改，采用root权限修改。

4、再次查看文件，已为默认值

![](https://pic4.zhimg.com/80/v2-de463d27d98f655615def7376a74bf33_720w.png)

5、将恢复后的TF卡插入树莓派启动即可。

# [【树莓派】设置开机自动挂载u盘](https://www.cnblogs.com/lw77/p/14117825.html)

1、查看u盘状态

sudo fdisk -l

![](https://img2020.cnblogs.com/blog/1843448/202012/1843448-20201210220329897-1400445306.png)

2、挂载u盘

sudo mount /dev/sda1 /media/USB_500G sudo mount /dev/sdb1 /media/flash_1T

3、查看u盘是否挂载成功

df -h

![](https://img2020.cnblogs.com/blog/1843448/202012/1843448-20201210220559019-1881647054.png)

4、卸载u盘

| 1<br><br>2 | `sudo` `umount` `/dev/sda1`<br><br>`sudo` `umount` `/dev/sdb1` |
| ---------- | -------------------------------------------------------------- |

 5、设置开机自动挂载u盘

在/etc/fstab文件中添加以下内容

![](https://img2020.cnblogs.com/blog/1843448/202012/1843448-20201210221306829-2015517242.png)

# ZeroTier One version 1.8.9 build 0 (platform 1 arch 3)